This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/dependabot.yml
.github/workflows/dependabot-automerge.yml
.github/workflows/lint-js.yml
.github/workflows/lint-rs.yml
.gitignore
.node-version
.repomixignore
biome.json
Cargo.toml
components.json
diagnostics.txt
eslint.config.mjs
importantcomments.txt
index.html
LICENSE
next-env.d.ts
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
repomix.config.json
src-tauri/.gitignore
src-tauri/.rustfmt.toml
src-tauri/build.rs
src-tauri/capabilities/default.json
src-tauri/Cargo.toml
src-tauri/src/commands/config_commands.rs
src-tauri/src/commands/edit_commands.rs
src-tauri/src/commands/filesystem_commands.rs
src-tauri/src/commands/mod.rs
src-tauri/src/commands/process_commands.rs
src-tauri/src/commands/ripgrep_commands.rs
src-tauri/src/commands/terminal_commands.rs
src-tauri/src/config.rs
src-tauri/src/error.rs
src-tauri/src/lib.rs
src-tauri/src/main.rs
src-tauri/src/mcp/handler.rs
src-tauri/src/mcp/mod.rs
src-tauri/src/mcp/schemas.rs
src-tauri/src/mcp/tool_impl/edit.rs
src-tauri/src/mcp/tool_impl/filesystem.rs
src-tauri/src/mcp/tool_impl/mod.rs
src-tauri/src/mcp/tool_impl/process.rs
src-tauri/src/mcp/tool_impl/ripgrep.rs
src-tauri/src/mcp/tool_impl/terminal.rs
src-tauri/src/utils/audit_logger.rs
src-tauri/src/utils/fuzzy_search_logger.rs
src-tauri/src/utils/line_ending_handler.rs
src-tauri/src/utils/mod.rs
src-tauri/src/utils/path_utils.rs
src-tauri/src/utils/terminal_session_manager.rs
src-tauri/tauri.conf.json
src/app/config/page.tsx
src/app/layout.tsx
src/app/page.tsx
src/components/RoundedButton.tsx
src/components/ui/alert.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/select.tsx
src/components/ui/sonner.tsx
src/components/ui/textarea.tsx
src/components/ui/tooltip.tsx
src/components/ui/use-toast.ts
src/lib/utils.ts
src/styles/globals.css
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/dependabot.yml">
version: 2
updates:
  # Enable version updates for Node.js dependencies
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    allow:
      - dependency-type: "all"
    groups:
      all:
        patterns:
          - "*"
    ignore:
      - dependency-name: "eslint"
        versions: ">= 9"

  # Enable version updates for rust
  - package-ecosystem: "cargo"
    directory: "/src-tauri"
    schedule:
      interval: "weekly"
    allow:
      - dependency-type: "all"
    groups:
      all:
        patterns:
          - "*"
</file>

<file path=".github/workflows/dependabot-automerge.yml">
# Automatically squashes and merges Dependabot dependency upgrades if tests pass

name: Dependabot Auto-merge

on: pull_request_target

permissions:
  pull-requests: write
  contents: write

jobs:
  dependabot:
    runs-on: ubuntu-latest

    if: ${{ github.actor == 'dependabot[bot]' }}
    steps:
      - name: Fetch Dependabot metadata
        id: dependabot-metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Approve Dependabot PR
        run: gh pr review --approve "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Auto-merge (squash) Dependabot PR
        if: ${{ steps.dependabot-metadata.outputs.update-type != 'version-update:semver-major' }}
        run: gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path=".github/workflows/lint-js.yml">
# Installs Node.js dependencies and pnpm, and checks formatting + linting

name: Lint Node.js

on:
  push:
    branches:
      - main
  pull_request:
    paths-ignore:
      - "src-tauri/**"
      - "README.md"

jobs:
  build:
    strategy:
      fail-fast: true
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}

    steps:
      - name: Disable git core.autocrlf on Windows
        if: matrix.os == 'windows-latest'
        run: git config --global core.autocrlf false

      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Set up pnpm package manager
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Set up Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version-file: .node-version
          cache: "pnpm"

      - name: Install dependencies from lockfile
        run: pnpm install --frozen-lockfile

      - name: Run lint step
        run: pnpm lint
</file>

<file path=".github/workflows/lint-rs.yml">
# Installs Rust and checks formatting + linting

name: Lint Rust

on:
  push:
    branches:
      - main
  pull_request:
    paths-ignore:
      - "src/**"
      - "package.json"
      - "package-lock.json"
      - "yarn.lock"
      - "pnpm-lock.yaml"
      - "README.md"

jobs:
  build:
    strategy:
      fail-fast: true
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}

    steps:
      - name: Disable git core.autocrlf on Windows
        if: matrix.os == 'windows-latest'
        run: git config --global core.autocrlf false

      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt install libwebkit2gtk-4.1-dev build-essential curl wget file libxdo-dev libssl-dev libayatana-appindicator3-dev librsvg2-dev

      - name: Create empty 'dist' directory
        run: mkdir dist

      - name: Run rustfmt check
        run: cargo fmt --all -- --check
        working-directory: src-tauri

      - name: Run clippy check and deny warnings
        run: cargo clippy --all-targets --all-features -- -D warnings
        working-directory: src-tauri
</file>

<file path=".node-version">
22
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "correctness": {
        "useHookAtTopLevel": "error"
      },
      "nursery": {
        "useGoogleFontDisplay": "error",
        "noDocumentImportInPage": "error",
        "noHeadElement": "error",
        "noHeadImportInDocument": "error",
        "noImgElement": "off",
        "useComponentExportOnlyModules": {
          "level": "error",
          "options": {
            "allowExportNames": ["metadata"]
          }
        }
      }
    }
  },
  "css": {
    "formatter": {
      "quoteStyle": "double"
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double"
    },
    "globals": []
  }
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/styles/globals.css",
    "baseColor": "stone",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="diagnostics.txt">
Parsed Rust Compiler Output:

--- Message 1 ---
Level: error
Message: unresolved imports `rust_mcp_schema::Content`, `rust_mcp_schema::RpcErrorCode`
File: src-tauri\src\mcp\handler.rs
Location: Line 14, Column 79
Label: no `Content` in the root
Code Context:     CallToolRequest, CallToolResult, ListToolsRequest, ListToolsResult, Tool, Content, // Content is a valid top-level import
  help: a similar name exists in the module
    Suggestion: RpcError
Full Rendered Output:
error[E0432]: unresolved imports `rust_mcp_schema::Content`, `rust_mcp_schema::RpcErrorCode`
  --> src-tauri\src\mcp\handler.rs:14:79
   |
14 | ...llToolResult, ListToolsRequest, ListToolsResult, Tool, Content, // Content is a valid top-level import
   |                                                           ^^^^^^^ no `Content` in the root
15 | ...oolError, RpcError, RpcErrorCode, // RpcErrorCode is also a valid top-level import
   |                        ^^^^^^^^^^^^
   |                        |
   |                        no `RpcErrorCode` in the root
   |                        help: a similar name exists in the module: `RpcError`




--- Message 2 ---
Level: error
Message: unresolved imports `tauri_plugin_fs::DirEntry`, `tauri_plugin_fs::ReadTextFileOptions`, `tauri_plugin_fs::WriteTextFileOptions`, `tauri_plugin_fs::DirOptions`
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 11, Column 23
Label: no `DirEntry` in the root
Code Context: use tauri_plugin_fs::{DirEntry, FilePath, FsExt, ReadTextFileOptions as FsReadTextFileOptions, WriteTextFileOptions as FsWriteTextFileOptions, DirOptions as FsDirOptions}; // Renamed to avoid conflict
  help: consider importing one of these structs instead:
std::fs::DirEntry
tokio::fs::DirEntry
Full Rendered Output:
error[E0432]: unresolved imports `tauri_plugin_fs::DirEntry`, `tauri_plugin_fs::ReadTextFileOptions`, `tauri_plugin_fs::WriteTextFileOptions`, `tauri_plugin_fs::DirOptions`
  --> src-tauri\src\mcp\tool_impl\filesystem.rs:11:23
   |
11 | ...::{DirEntry, FilePath, FsExt, ReadTextFileOptions as FsReadTextFileOptions, WriteTextFileOptions as FsWriteTextFileOptions, DirOptions as FsDirOptions}; ...
   |       ^^^^^^^^                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^ no `DirOptions` in the root
   |       |                          |                                             |
   |       |                          |                                             no `WriteTextFileOptions` in the root
   |       |                          no `ReadTextFileOptions` in the root
   |       no `DirEntry` in the root
   |
   = help: consider importing one of these structs instead:
           std::fs::DirEntry
           tokio::fs::DirEntry




--- Message 3 ---
Level: error
Message: unresolved import `tauri_plugin_log::TauriLogger`
File: src-tauri\src\lib.rs
Location: Line 23, Column 5
Label: no `TauriLogger` in the root
Code Context: use tauri_plugin_log::TauriLogger; // Assuming this is the correct type for the layer
Full Rendered Output:
error[E0432]: unresolved import `tauri_plugin_log::TauriLogger`
  --> src-tauri\src\lib.rs:23:5
   |
23 | use tauri_plugin_log::TauriLogger; // Assuming this is the correct type for the layer
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `TauriLogger` in the root




--- Message 4 ---
Level: warning
Message: unused import: `warn`
File: src-tauri\src\mcp\tool_impl\edit.rs
Location: Line 13, Column 34
Code Context: use tracing::{debug, instrument, warn}; // Corrected warn import
  note: `#[warn(unused_imports)]` on by default
  help: remove the unused import
Full Rendered Output:
warning: unused import: `warn`
  --> src-tauri\src\mcp\tool_impl\edit.rs:13:34
   |
13 | use tracing::{debug, instrument, warn}; // Corrected warn import
   |                                  ^^^^
   |
   = note: `#[warn(unused_imports)]` on by default




--- Message 5 ---
Level: error
Message: no method named `read_binary_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 158, Column 37
Label: method not found in `AppHandle`
Code Context:         let bytes = deps.app_handle.read_binary_file(FilePath::Path(path)).await.map_err(|e| AppError::PluginError{ plugin:"fs".to_string(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `read_binary_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:158:37
    |
158 | ...   let bytes = deps.app_handle.read_binary_file(FilePath::Path(path)).await.map_err(|e| AppError::PluginEr...
    |                                   ^^^^^^^^^^^^^^^^ method not found in `AppHandle`




--- Message 6 ---
Level: error
Message: no method named `read_text_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 161, Column 44
Label: method not found in `AppHandle`
Code Context:         let full_content = deps.app_handle.read_text_file(FilePath::Path(path), None::<FsReadTextFileOptions>).await.map_err(|e| AppError::PluginError{ plugin:"fs".to_string(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `read_text_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:161:44
    |
161 | ...   let full_content = deps.app_handle.read_text_file(FilePath::Path(path), None::<FsReadTextFileOptions>)....
    |                                          ^^^^^^^^^^^^^^ method not found in `AppHandle`




--- Message 7 ---
Level: error
Message: no method named `exists` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 188, Column 87
Code Context:     let final_content_str = if params.mode == WriteModeMCP::Append && deps.app_handle.exists(FilePath::Path(path.clone()), None).await.unwrap_or(false) {
  help: there is a method `exit` with a similar name, but with different arguments
Full Rendered Output:
error[E0599]: no method named `exists` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:188:87
    |
188 |     let final_content_str = if params.mode == WriteModeMCP::Append && deps.app_handle.exists(FilePath::Path(p...
    |                                                                                       ^^^^^^
    |
help: there is a method `exit` with a similar name, but with different arguments
   --> C:\Users\Steve Business\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\tauri-2.5.1\src\app.rs:528:3
    |
528 |   pub fn exit(&self, exit_code: i32) {
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




--- Message 8 ---
Level: error
Message: no method named `read_text_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 189, Column 52
Label: method not found in `AppHandle`
Code Context:         let existing_content_str = deps.app_handle.read_text_file(FilePath::Path(path.clone()), None::<FsReadTextFileOptions>).await.unwrap_or_default();
Full Rendered Output:
error[E0599]: no method named `read_text_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:189:52
    |
189 | ...   let existing_content_str = deps.app_handle.read_text_file(FilePath::Path(path.clone()), None::<FsReadTe...
    |                                                  ^^^^^^^^^^^^^^ method not found in `AppHandle`




--- Message 9 ---
Level: error
Message: no method named `write_text_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 202, Column 21
Label: method not found in `AppHandle`
Code Context:     deps.app_handle.write_text_file(options).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `write_text_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:202:21
    |
202 |     deps.app_handle.write_text_file(options).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), ...
    |                     ^^^^^^^^^^^^^^^ method not found in `AppHandle`




--- Message 10 ---
Level: error
Message: no method named `create_dir` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 212, Column 21
Label: method not found in `AppHandle`
Code Context:     deps.app_handle.create_dir(FilePath::Path(path), Some(FsDirOptions { recursive: true })).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `create_dir` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:212:21
    |
212 |     deps.app_handle.create_dir(FilePath::Path(path), Some(FsDirOptions { recursive: true })).await.map_err(|e...
    |                     ^^^^^^^^^^ method not found in `AppHandle`




--- Message 11 ---
Level: error
Message: no method named `read_dir` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 221, Column 40
Label: method not found in `AppHandle`
Code Context:     let entries_data = deps.app_handle.read_dir(FilePath::Path(path), Some(FsDirOptions { recursive: false })).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `read_dir` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:221:40
    |
221 |     let entries_data = deps.app_handle.read_dir(FilePath::Path(path), Some(FsDirOptions { recursive: false })...
    |                                        ^^^^^^^^ method not found in `AppHandle`




--- Message 12 ---
Level: error
Message: no method named `rename_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 233, Column 21
Label: method not found in `AppHandle`
Code Context:     deps.app_handle.rename_file(FilePath::Path(source_path), FilePath::Path(dest_path)).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `rename_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:233:21
    |
233 |     deps.app_handle.rename_file(FilePath::Path(source_path), FilePath::Path(dest_path)).await.map_err(|e|AppE...
    |                     ^^^^^^^^^^^ method not found in `AppHandle`




--- Message 13 ---
Level: error
Message: no method named `metadata` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 242, Column 36
Label: method not found in `AppHandle`
Code Context:     let metadata = deps.app_handle.metadata(FilePath::Path(path.clone())).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
Full Rendered Output:
error[E0599]: no method named `metadata` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:242:36
    |
242 |     let metadata = deps.app_handle.metadata(FilePath::Path(path.clone())).await.map_err(|e|AppError::PluginEr...
    |                                    ^^^^^^^^ method not found in `AppHandle`




--- Message 14 ---
Level: error
Message: no method named `read_binary_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 291, Column 45
Label: method not found in `AppHandle`
Code Context:                             deps.app_handle.read_binary_file(FilePath::Path(val_path)).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), message:e.to_string()})
Full Rendered Output:
error[E0599]: no method named `read_binary_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:291:45
    |
291 | ...   deps.app_handle.read_binary_file(FilePath::Path(val_path)).await.map_err(|e|AppError::PluginError{plugi...
    |                       ^^^^^^^^^^^^^^^^ method not found in `AppHandle`




--- Message 15 ---
Level: error
Message: no method named `read_text_file` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 294, Column 45
Label: method not found in `AppHandle`
Code Context:                             deps.app_handle.read_text_file(FilePath::Path(val_path), None::<FsReadTextFileOptions>).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), message:e.to_string()})
Full Rendered Output:
error[E0599]: no method named `read_text_file` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:294:45
    |
294 | ...   deps.app_handle.read_text_file(FilePath::Path(val_path), None::<FsReadTextFileOptions>).await.map_err(|...
    |                       ^^^^^^^^^^^^^^ method not found in `AppHandle`




--- Message 16 ---
Level: error
Message: no method named `read_dir` found for reference `&AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 332, Column 41
Label: method not found in `&AppHandle`
Code Context:     let dir_entries_result = app_handle.read_dir(FilePath::Path(dir_to_search.clone()), Some(FsDirOptions { recursive: false })).await;
Full Rendered Output:
error[E0599]: no method named `read_dir` found for reference `&AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:332:41
    |
332 |     let dir_entries_result = app_handle.read_dir(FilePath::Path(dir_to_search.clone()), Some(FsDirOptions { r...
    |                                         ^^^^^^^^ method not found in `&AppHandle`




--- Message 17 ---
Level: error
Message: no method named `read_dir` found for struct `AppHandle` in the current scope
File: src-tauri\src\mcp\tool_impl\filesystem.rs
Location: Line 383, Column 48
Label: method not found in `AppHandle`
Code Context:             let dir_entries = app_handle_clone.read_dir(FilePath::Path(root_search_path), Some(FsDirOptions { recursive: false })).await.map_err(|e| AppError::PluginError { plugin: "fs".to_string(), message: e.to_string() })?;
Full Rendered Output:
error[E0599]: no method named `read_dir` found for struct `AppHandle` in the current scope
   --> src-tauri\src\mcp\tool_impl\filesystem.rs:383:48
    |
383 | ...   let dir_entries = app_handle_clone.read_dir(FilePath::Path(root_search_path), Some(FsDirOptions { recur...
    |                                          ^^^^^^^^ method not found in `AppHandle`




--- Message 18 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 117, Column 21
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:             Ok(Some(Ok(event))) => { // Successfully received an event
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:117:21
    |
116 |         match timeout(Duration::from_millis(50), rx.recv()).await {
    |               --------------------------------------------------- this expression has type `std::result::Result<std::option::Option<CommandEvent>, Elapsed>`
117 |             Ok(Some(Ok(event))) => { // Successfully received an event
    |                     ^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 19 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 126, Column 21
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:             Ok(Some(Err(shell_error))) => { // ShellError from the stream
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:126:21
    |
116 |         match timeout(Duration::from_millis(50), rx.recv()).await {
    |               --------------------------------------------------- this expression has type `std::result::Result<std::option::Option<CommandEvent>, Elapsed>`
...
126 |             Ok(Some(Err(shell_error))) => { // ShellError from the stream
    |                     ^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 20 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 147, Column 26
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:                     Some(Ok(CommandEvent::Stdout(line))) => {
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:147:26
    |
146 |                 match rx.recv().await {
    |                       --------------- this expression has type `std::option::Option<CommandEvent>`
147 |                     Some(Ok(CommandEvent::Stdout(line))) => {
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 21 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 150, Column 26
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:                     Some(Ok(CommandEvent::Stderr(line))) => {
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:150:26
    |
146 |                 match rx.recv().await {
    |                       --------------- this expression has type `std::option::Option<CommandEvent>`
...
150 |                     Some(Ok(CommandEvent::Stderr(line))) => {
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 22 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 153, Column 26
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:                     Some(Ok(CommandEvent::Terminated(payload))) => {
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:153:26
    |
146 |                 match rx.recv().await {
    |                       --------------- this expression has type `std::option::Option<CommandEvent>`
...
153 |                     Some(Ok(CommandEvent::Terminated(payload))) => {
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 23 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 160, Column 26
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:                     Some(Ok(CommandEvent::Error(message))) => {
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:160:26
    |
146 |                 match rx.recv().await {
    |                       --------------- this expression has type `std::option::Option<CommandEvent>`
...
160 |                     Some(Ok(CommandEvent::Error(message))) => {
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 24 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 167, Column 26
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:                     Some(Ok(_other_event)) => { /* e.g. CommandEvent::Pid - can ignore or log */ }
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:167:26
    |
146 |                 match rx.recv().await {
    |                       --------------- this expression has type `std::option::Option<CommandEvent>`
...
167 |                     Some(Ok(_other_event)) => { /* e.g. CommandEvent::Pid - can ignore or log */ }
    |                          ^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 25 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\tool_impl\terminal.rs
Location: Line 168, Column 26
Label: expected `CommandEvent`, found `Result<_, _>`
Code Context:                     Some(Err(shell_error)) => { // ShellError from the stream in background task
  note: expected enum `CommandEvent`
   found enum `std::result::Result<_, _>`
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\mcp\tool_impl\terminal.rs:168:26
    |
146 |                 match rx.recv().await {
    |                       --------------- this expression has type `std::option::Option<CommandEvent>`
...
168 |                     Some(Err(shell_error)) => { // ShellError from the stream in background task
    |                          ^^^^^^^^^^^^^^^^ expected `CommandEvent`, found `Result<_, _>`
    |
    = note: expected enum `CommandEvent`
               found enum `std::result::Result<_, _>`




--- Message 26 ---
Level: error
Message: no method named `read_text_file` found for reference `&tauri_plugin_fs::Fs<tauri_runtime_wry::Wry<EventLoopMessage>>` in the current scope
File: src-tauri\src\mcp\tool_impl\edit.rs
Location: Line 59, Column 44
Label: method not found in `&Fs<Wry<EventLoopMessage>>`
Code Context:     let original_content = app_handle.fs().read_text_file(&path).await
Full Rendered Output:
error[E0599]: no method named `read_text_file` found for reference `&tauri_plugin_fs::Fs<tauri_runtime_wry::Wry<EventLoopMessage>>` in the current scope
  --> src-tauri\src\mcp\tool_impl\edit.rs:59:44
   |
59 |     let original_content = app_handle.fs().read_text_file(&path).await
   |                                            ^^^^^^^^^^^^^^ method not found in `&Fs<Wry<EventLoopMessage>>`




--- Message 27 ---
Level: error
Message: no method named `write_text_file` found for reference `&tauri_plugin_fs::Fs<tauri_runtime_wry::Wry<EventLoopMessage>>` in the current scope
File: src-tauri\src\mcp\tool_impl\edit.rs
Location: Line 74, Column 21
Label: method not found in `&Fs<Wry<EventLoopMessage>>`
Code Context:     app_handle.fs().write_text_file(path_obj, content).await
Full Rendered Output:
error[E0599]: no method named `write_text_file` found for reference `&tauri_plugin_fs::Fs<tauri_runtime_wry::Wry<EventLoopMessage>>` in the current scope
  --> src-tauri\src\mcp\tool_impl\edit.rs:74:21
   |
74 |     app_handle.fs().write_text_file(path_obj, content).await
   |                     ^^^^^^^^^^^^^^^ method not found in `&Fs<Wry<EventLoopMessage>>`




--- Message 28 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\schemas.rs
Location: Line 47, Column 50
Label: expected `Vec<String>`, found `Option<_>`
Code Context:         required: if required_props.is_empty() { None } else { Some(required_props) },
  note: expected struct `Vec<std::string::String>`
     found enum `std::option::Option<_>`
Full Rendered Output:
error[E0308]: mismatched types
  --> src-tauri\src\mcp\schemas.rs:47:50
   |
47 |         required: if required_props.is_empty() { None } else { Some(required_props) },
   |                                                  ^^^^ expected `Vec<String>`, found `Option<_>`
   |
   = note: expected struct `Vec<std::string::String>`
                found enum `std::option::Option<_>`




--- Message 29 ---
Level: error
Message: mismatched types
File: src-tauri\src\mcp\schemas.rs
Location: Line 47, Column 64
Label: expected `Vec<String>`, found `Option<Vec<String>>`
Code Context:         required: if required_props.is_empty() { None } else { Some(required_props) },
  note: expected struct `Vec<_>`
     found enum `std::option::Option<Vec<_>>`
Full Rendered Output:
error[E0308]: mismatched types
  --> src-tauri\src\mcp\schemas.rs:47:64
   |
47 |         required: if required_props.is_empty() { None } else { Some(required_props) },
   |                                                                ^^^^^^^^^^^^^^^^^^^^ expected `Vec<String>`, found `Option<Vec<String>>`
   |
   = note: expected struct `Vec<_>`
                found enum `std::option::Option<Vec<_>>`




--- Message 30 ---
Level: error
Message: struct `ToolInputSchema` has no field named `meta`
File: src-tauri\src\mcp\schemas.rs
Location: Line 49, Column 9
Label: `ToolInputSchema` does not have this field
Code Context:         meta: None,
  note: all struct fields are already assigned
Full Rendered Output:
error[E0560]: struct `ToolInputSchema` has no field named `meta`
  --> src-tauri\src\mcp\schemas.rs:49:9
   |
49 |         meta: None,
   |         ^^^^ `ToolInputSchema` does not have this field
   |
   = note: all struct fields are already assigned




--- Message 31 ---
Level: error
Message: expected a `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
File: src-tauri\src\lib.rs
Location: Line 53, Column 17
Label: expected an `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
Code Context:         .filter(EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", level))), // Corrected method name
  help: the trait `for<'a, 'b> Fn(&'a tracing::log::Metadata<'b>)` is not implemented for `EnvFilter`
  note: required by a bound in `tauri_plugin_log::Target::filter`
Full Rendered Output:
error[E0277]: expected a `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
   --> src-tauri\src\lib.rs:53:17
    |
53  |         .filter(EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", level))), // Corrected method name
    |          ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
    |          |
    |          required by a bound introduced by this call
    |
    = help: the trait `for<'a, 'b> Fn(&'a tracing::log::Metadata<'b>)` is not implemented for `EnvFilter`
note: required by a bound in `tauri_plugin_log::Target::filter`
   --> C:\Users\Steve Business\.cargo\git\checkouts\plugins-workspace-bac95421cc662c04\764e8f7\plugins\log\src\lib.rs:197:12
    |
195 |     pub fn filter<F>(mut self, filter: F) -> Self
    |            ------ required by a bound in this associated function
196 |     where
197 |         F: Fn(&log::Metadata) -> bool + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Target::filter`




--- Message 32 ---
Level: error
Message: expected a `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
File: src-tauri\src\lib.rs
Location: Line 55, Column 21
Label: expected an `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
Code Context:             .filter(EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", Level::INFO))), // Corrected method name
  help: the trait `for<'a, 'b> Fn(&'a tracing::log::Metadata<'b>)` is not implemented for `EnvFilter`
  note: required by a bound in `tauri_plugin_log::Target::filter`
Full Rendered Output:
error[E0277]: expected a `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
   --> src-tauri\src\lib.rs:55:21
    |
55  |             .filter(EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", Level::INFO))), // Corrected method ...
    |              ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn(&tracing::log::Metadata<'_>)` closure, found `EnvFilter`
    |              |
    |              required by a bound introduced by this call
    |
    = help: the trait `for<'a, 'b> Fn(&'a tracing::log::Metadata<'b>)` is not implemented for `EnvFilter`
note: required by a bound in `tauri_plugin_log::Target::filter`
   --> C:\Users\Steve Business\.cargo\git\checkouts\plugins-workspace-bac95421cc662c04\764e8f7\plugins\log\src\lib.rs:197:12
    |
195 |     pub fn filter<F>(mut self, filter: F) -> Self
    |            ------ required by a bound in this associated function
196 |     where
197 |         F: Fn(&log::Metadata) -> bool + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Target::filter`




--- Message 33 ---
Level: error
Message: mismatched types
File: src-tauri\src\lib.rs
Location: Line 65, Column 33
Label: expected `LevelFilter`, found `Level`
Code Context:             .level_for("hyper", tracing::Level::WARN) // Corrected to tracing::Level
  note: method defined here
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\lib.rs:65:33
    |
65  |             .level_for("hyper", tracing::Level::WARN) // Corrected to tracing::Level
    |              ---------          ^^^^^^^^^^^^^^^^^^^^ expected `LevelFilter`, found `Level`
    |              |
    |              arguments to this method are incorrect
    |
note: method defined here
   --> C:\Users\Steve Business\.cargo\git\checkouts\plugins-workspace-bac95421cc662c04\764e8f7\plugins\log\src\lib.rs:350:12
    |
350 |     pub fn level_for(mut self, module: impl Into<Cow<'static, str>>, level: LevelFilter) -> Self {
    |            ^^^^^^^^^




--- Message 34 ---
Level: error
Message: mismatched types
File: src-tauri\src\lib.rs
Location: Line 66, Column 34
Label: expected `LevelFilter`, found `Level`
Code Context:             .level_for("rustls", tracing::Level::WARN) // Corrected to tracing::Level
  note: method defined here
Full Rendered Output:
error[E0308]: mismatched types
   --> src-tauri\src\lib.rs:66:34
    |
66  |             .level_for("rustls", tracing::Level::WARN) // Corrected to tracing::Level
    |              ---------           ^^^^^^^^^^^^^^^^^^^^ expected `LevelFilter`, found `Level`
    |              |
    |              arguments to this method are incorrect
    |
note: method defined here
   --> C:\Users\Steve Business\.cargo\git\checkouts\plugins-workspace-bac95421cc662c04\764e8f7\plugins\log\src\lib.rs:350:12
    |
350 |     pub fn level_for(mut self, module: impl Into<Cow<'static, str>>, level: LevelFilter) -> Self {
    |            ^^^^^^^^^




--- Message 35 ---
Level: warning
Message: unused import: `Layer`
File: src-tauri\src\lib.rs
Location: Line 15, Column 114
Code Context: use tracing_subscriber::{filter::EnvFilter, fmt::format::FmtSpan, layer::SubscriberExt, util::SubscriberInitExt, Layer as TracingLayerExt}; // Renamed Layer to avoid conflict
Full Rendered Output:
warning: unused import: `Layer`
  --> src-tauri\src\lib.rs:15:114
   |
15 | ...an, layer::SubscriberExt, util::SubscriberInitExt, Layer as TracingLayerExt}; // Renamed Layer to avoid con...
   |                                                       ^^^^^




--- Message 36 ---
Level: failure-note
Message: Some errors have detailed explanations: E0277, E0308, E0432, E0560, E0599.
Full Rendered Output:
Some errors have detailed explanations: E0277, E0308, E0432, E0560, E0599.



--- Message 37 ---
Level: failure-note
Message: For more information about an error, try `rustc --explain E0277`.
Full Rendered Output:
For more information about an error, try `rustc --explain E0277`.
</file>

<file path="eslint.config.mjs">
import { FlatCompat } from "@eslint/eslintrc";
import eslint from "@eslint/js";
import tseslint from "typescript-eslint";

const compat = new FlatCompat({
  baseDirectory: import.meta.dirname,
});

const eslintConfig = tseslint.config(
  eslint.configs.recommended,
  tseslint.configs.strictTypeChecked,
  tseslint.configs.stylisticTypeChecked,
  ...compat.extends("next/core-web-vitals"),
  {
    // Disabled rules taken from https://biomejs.dev/linter/rules-sources for ones that
    // are already handled by Biome
    rules: {
      // eslint-plugin-jsx-a11y rules replaced by Biome
      "jsx-a11y/alt-text": "off",
      "jsx-a11y/anchor-has-content": "off",
      "jsx-a11y/anchor-is-valid": "off",
      "jsx-a11y/aria-activedescendant-has-tabindex": "off",
      "jsx-a11y/aria-props": "off",
      "jsx-a11y/aria-proptypes": "off",
      "jsx-a11y/aria-role": "off",
      "jsx-a11y/aria-unsupported-elements": "off",
      "jsx-a11y/autocomplete-valid": "off",
      "jsx-a11y/click-events-have-key-events": "off",
      "jsx-a11y/heading-has-content": "off",
      "jsx-a11y/html-has-lang": "off",
      "jsx-a11y/iframe-has-title": "off",
      "jsx-a11y/img-redundant-alt": "off",
      "jsx-a11y/interactive-supports-focus": "off",
      "jsx-a11y/label-has-associated-control": "off",
      "jsx-a11y/lang": "off",
      "jsx-a11y/media-has-caption": "off",
      "jsx-a11y/mouse-events-have-key-events": "off",
      "jsx-a11y/no-access-key": "off",
      "jsx-a11y/no-aria-hidden-on-focusable": "off",
      "jsx-a11y/no-autofocus": "off",
      "jsx-a11y/no-distracting-elements": "off",
      "jsx-a11y/no-interactive-element-to-noninteractive-role": "off",
      "jsx-a11y/no-noninteractive-element-to-interactive-role": "off",
      "jsx-a11y/no-noninteractive-tabindex": "off",
      "jsx-a11y/no-redundant-roles": "off",
      "jsx-a11y/no-static-element-interactions": "off",
      "jsx-a11y/prefer-tag-over-role": "off",
      "jsx-a11y/role-has-required-aria-props": "off",
      "jsx-a11y/role-supports-aria-props": "off",
      "jsx-a11y/scope": "off",
      "jsx-a11y/tabindex-no-positive": "off",
      // eslint-plugin-react rules replaced by Biome
      "react/button-has-type": "off",
      "react/jsx-boolean-value": "off",
      "react/jsx-curly-brace-presence": "off",
      "react/jsx-fragments": "off",
      "react/jsx-key": "off",
      "react/jsx-no-comment-textnodes": "off",
      "react/jsx-no-duplicate-props": "off",
      "react/jsx-no-target-blank": "off",
      "react/jsx-no-useless-fragment": "off",
      "react/no-array-index-key": "off",
      "react/no-children-prop": "off",
      "react/no-danger": "off",
      "react/no-danger-with-children": "off",
      "react/void-dom-elements-no-children": "off",
      // eslint-plugin-react-hooks rules replaced by Biome
      "react-hooks/exhaustive-deps": "off",
      "react-hooks/rules-of-hooks": "off",
      // typescript-eslint rules replaced by Biome
      "@typescript-eslint/adjacent-overload-signatures": "off",
      "@typescript-eslint/array-type": "off",
      "@typescript-eslint/ban-types": "off",
      "@typescript-eslint/consistent-type-exports": "off",
      "@typescript-eslint/consistent-type-imports": "off",
      "@typescript-eslint/default-param-last": "off",
      "@typescript-eslint/dot-notation": "off",
      "@typescript-eslint/explicit-function-return-type": "off",
      "@typescript-eslint/explicit-member-accessibility": "off",
      "@typescript-eslint/naming-convention": "off",
      "@typescript-eslint/no-dupe-class-members": "off",
      "@typescript-eslint/no-empty-function": "off",
      "@typescript-eslint/no-empty-interface": "off",
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-extra-non-null-assertion": "off",
      "@typescript-eslint/no-extraneous-class": "off",
      "@typescript-eslint/no-inferrable-types": "off",
      "@typescript-eslint/no-invalid-void-type": "off",
      "@typescript-eslint/no-loss-of-precision": "off",
      "@typescript-eslint/no-misused-new": "off",
      "@typescript-eslint/no-namespace": "off",
      "@typescript-eslint/no-non-null-assertion": "off",
      "@typescript-eslint/no-redeclare": "off",
      "@typescript-eslint/no-require-imports": "off",
      "@typescript-eslint/no-restricted-imports": "off",
      "@typescript-eslint/no-restricted-types": "off",
      "@typescript-eslint/no-this-alias": "off",
      "@typescript-eslint/no-unnecessary-type-constraint": "off",
      "@typescript-eslint/no-unsafe-declaration-merging": "off",
      "@typescript-eslint/no-unused-vars": "off",
      "@typescript-eslint/no-use-before-define": "off",
      "@typescript-eslint/no-useless-constructor": "off",
      "@typescript-eslint/no-useless-empty-export": "off",
      "@typescript-eslint/only-throw-error": "off",
      "@typescript-eslint/parameter-properties": "off",
      "@typescript-eslint/prefer-as-const": "off",
      "@typescript-eslint/prefer-enum-initializers": "off",
      "@typescript-eslint/prefer-for-of": "off",
      "@typescript-eslint/prefer-function-type": "off",
      "@typescript-eslint/prefer-literal-enum-member": "off",
      "@typescript-eslint/prefer-namespace-keyword": "off",
      "@typescript-eslint/prefer-optional-chain": "off",
      "@typescript-eslint/require-await": "off",
      // Custom rules
      "@typescript-eslint/restrict-template-expressions": [
        "error",
        {
          allowNumber: true,
          allowBoolean: true,
          allowNever: true,
        },
      ],
    },
    languageOptions: {
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
);

export default eslintConfig;
</file>

<file path="importantcomments.txt">
Comments from default.json:

// Example: Allow rg if in PATH and configured in tauri.conf.json plugin scope
// { "name": "rg", "cmd": "rg", "args": true, "sidecar": false }

// Example: Allow rg if bundled as sidecar
// { "name": "binaries/rg" }

// FS scopes will be more specific, these are placeholders

// Allow specific paths based on your FILES_ROOT and ALLOWED_DIRECTORIES
// Example: { "identifier": "fs:allow-read-recursive", "allow": [{ "path": "$HOME/projects/**" }] }

// For basic process plugin use
// For basic http plugin use
// Allow HTTP requests

// Global FS scope, also to be configured based on FILES_ROOT

// Globally allowed commands
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri + React + Typescript</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2022 Kevin Xiao

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactStrictMode: true,
  output: "export",
  images: {
    unoptimized: true,
  },
  distDir: "dist",
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output-tauri-nextjs.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="src-tauri/.rustfmt.toml">
tab_spaces = 2
max_width = 100
</file>

<file path="src-tauri/build.rs">
fn main() {
  tauri_build::build()
}
</file>

<file path="src-tauri/src/utils/mod.rs">
pub mod audit_logger;
pub mod fuzzy_search_logger;
pub mod line_ending_handler;
pub mod path_utils;
// pub mod terminal_session_manager; // If we create a dedicated manager
</file>

<file path="src-tauri/src/utils/terminal_session_manager.rs">
// This file is a placeholder for now.
// The terminal session management logic is currently within `commands/terminal_commands.rs`
// using the `ActiveSessionsMap` state.
// If it grows too complex, parts could be refactored here.

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex as TokioMutex;
use tauri_plugin_shell::process::CommandChild;

#[derive(Debug)]
pub struct TerminalSession {
    pub id: String,
    pub command: String,
    pub child: Arc<TokioMutex<CommandChild>>,
    pub pid: Option<u32>,
    pub start_time: std::time::Instant,
    pub exit_code: Arc<TokioMutex<Option<i32>>>,
    // Potentially a buffer for recent output if needed beyond events
    // pub output_buffer: Arc<TokioMutex<Vec<String>>>,
}

#[derive(Default, Debug)]
pub struct TerminalSessionManager {
    sessions: HashMap<String, Arc<TerminalSession>>,
}

impl TerminalSessionManager {
    pub fn new() -> Self {
        Default::default()
    }

    // Methods to add, remove, get sessions, etc. would go here
    // For now, this logic is directly in terminal_commands.rs using the HashMap state.
}
</file>

<file path="src/components/RoundedButton.tsx">
interface RoundedButtonProps {
  onClick: () => void;
  title: string;
}

export const RoundedButton: React.FC<RoundedButtonProps> = ({
  onClick,
  title,
}) => (
  <button
    type="button"
    onClick={onClick}
    className="m-4 max-w-xs rounded-xl border border-gray-200 p-6 text-left text-inherit transition-colors hover:border-blue-600 hover:text-blue-600 focus:border-blue-600 focus:text-blue-600 active:border-blue-600 active:text-blue-600cursor-pointer rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:min-w-44"
  >
    {title}
  </button>
);
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/components/ui/use-toast.ts">
// src/components/ui/use-toast.ts
// Shim for legacy code. Prefer using `import { toast } from "sonner"` directly.
import { toast } from "sonner";

// Accepts a string or a minimal object with title/description/variant for compatibility
export function useToast() {
  return {
    toast: (opts: string | { title?: string; description?: string; variant?: string }) => {
      if (typeof opts === "string") {
        toast(opts);
      } else if (typeof opts === "object") {
        if (opts.variant === "destructive") {
          toast.error(opts.description ?? opts.title ?? "Error");
        } else {
          toast.success(opts.description ?? opts.title ?? "Success");
        }
      }
    },
  };
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "forceConsistentCasingInFileNames": true,
    "target": "ES2021",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "dist/types/**/*.ts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="package.json">
{
  "name": "tauri-nextjs-template",
  "private": true,
  "version": "0.2.0",
  "type": "module",
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "biome check src/ && next lint",
    "tauri": "tauri"
  },
  "dependencies": {
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-opener": "^2.2.6",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.511.0",
    "next": "^15.3.2",
    "next-themes": "^0.4.6",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@eslint/eslintrc": "^3.3.1",
    "@eslint/js": "^9.27.0",
    "@next/eslint-plugin-next": "^15.3.2",
    "@tailwindcss/postcss": "^4.1.7",
    "@tauri-apps/cli": "^2",
    "@types/node": "^22.15.19",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@typescript-eslint/eslint-plugin": "^8.32.1",
    "@typescript-eslint/parser": "^8.32.1",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.21.0",
    "eslint-config-next": "^15.3.2",
    "eslint-plugin-react-hooks": "^5.2.0",
    "tailwindcss": "^4.1.7",
    "tw-animate-css": "^1.3.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.32.1"
  }
}
</file>

<file path="src-tauri/src/commands/mod.rs">
pub mod config_commands;
pub mod filesystem_commands;
pub mod ripgrep_commands;
pub mod terminal_commands;
pub mod process_commands;
pub mod edit_commands;

// A simple greet command for initial testing
#[tauri::command]
pub fn greet() -> String {
  let now = std::time::SystemTime::now();
  match now.duration_since(std::time::UNIX_EPOCH) {
    Ok(n) => format!("Hello from Rust (Tauri)! Current epoch ms: {}", n.as_millis()),
    Err(_) => "Hello from Rust (Tauri)! Could not get epoch time.".to_string(),
  }
}
</file>

<file path="src-tauri/src/commands/process_commands.rs">
// This file's commands are now largely superseded by MCP tools.
// For this iteration, this file will be empty of commands, assuming MCP is the primary interface.
// If UI needs direct calls to process management logic not via MCP, define them here.
// Example:
/*
use crate::error::AppError;
use crate::utils::audit_logger::audit_log;
use crate::mcp::tool_impl::process as mcp_process_impl;
use crate::mcp::handler::ToolDependencies;
use crate::config::Config;

use serde::{Deserialize, Serialize};
use std::sync::{Arc, RwLock as StdRwLock};
use tauri::{AppHandle, Manager, State};
use tokio::sync::Mutex as TokioMutex;
use tracing::instrument;

#[derive(Debug, Deserialize, Serialize)]
pub struct KillProcessParams {
    pub pid: usize,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProcessInfo {
    pid: String,
    name: String,
    cpu_usage: f32,
    memory_mb: u64,
    command: String,
    status: String,
    user: Option<String>,
    start_time_epoch_secs: u64,
}

#[derive(Debug, Serialize)]
pub struct KillProcessResult {
    pub success: bool,
    pub message: String,
}

pub type SysinfoState = Arc<TokioMutex<sysinfo::System>>;

fn get_tool_dependencies_for_ui(app_handle: &AppHandle, config_state: &State<'_, Arc<StdRwLock<Config>>>) -> ToolDependencies {
    ToolDependencies {
        app_handle: app_handle.clone(),
        config_state: config_state.inner().clone(),
        audit_logger: app_handle.state::<Arc<crate::utils::audit_logger::AuditLogger>>().inner().clone(),
        fuzzy_search_logger: app_handle.state::<Arc<crate::utils::fuzzy_search_logger::FuzzySearchLogger>>().inner().clone(),
        active_sessions_map: app_handle.state::<crate::commands::terminal_commands::ActiveSessionsMap>().inner().clone(),
        sysinfo_state: app_handle.state::<SysinfoState>().inner().clone(),
    }
}

#[tauri::command(async)]
#[instrument(skip(app_handle, audit_logger_state, config_state, _sysinfo_state))]
pub async fn list_processes_command_ui_wrapper(
    app_handle: AppHandle,
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
    _sysinfo_state: State<'_, SysinfoState>,
) -> Result<Vec<ProcessInfo>, AppError> {
    audit_log(&audit_logger_state, "ui_list_processes_wrapper", &serde_json::Value::Null).await;
    let deps = get_tool_dependencies_for_ui(&app_handle, &config_state);
    mcp_process_impl::mcp_list_processes(&deps).await
        .map(|mcp_infos| {
            mcp_infos.into_iter().map(|mcp_info| {
                let mcp_info_json = serde_json::to_value(mcp_info).unwrap();
                serde_json::from_value(mcp_info_json).unwrap()
            }).collect()
        })
}

#[tauri::command(async)]
#[instrument(skip(app_handle, audit_logger_state, config_state, _sysinfo_state, params), fields(pid = %params.pid))]
pub async fn kill_process_command_ui_wrapper(
    app_handle: AppHandle,
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
    _sysinfo_state: State<'_, SysinfoState>,
    params: KillProcessParams,
) -> Result<KillProcessResult, AppError> {
    audit_log(&audit_logger_state, "ui_kill_process_wrapper", &serde_json::to_value(ms)?).await;
    let deps = get_tool_dependencies_for_ui(&app_handle, &config_state);
    let mcp_params = crate::mcp::tool_impl::process::KillProcessParamsMCP { pid: params.pid };
    mcp_process_impl::mcp_kill_process(&deps, mcp_params).await
        .map(|mcp_res| KillProcessResult { success: mcp_res.success, message: mcp_res.message })
}
*/
</file>

<file path="src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
  mcp_rg_editor_tauri_lib::run();
}
</file>

<file path="src-tauri/src/mcp/mod.rs">
pub mod handler;
pub mod schemas;
pub mod tool_impl;

use tauri::AppHandle;
use std::sync::{Arc, RwLock};
use crate::config::Config;

// Struct to pass to the MCP Server thread, if needed (currently handler takes AppHandle and Config directly)
#[derive(Clone)]
pub struct McpServerLaunchParams {
    pub app_handle: AppHandle,
    pub config_state: Arc<RwLock<Config>>,
}
</file>

<file path="src-tauri/src/mcp/tool_impl/mod.rs">
// FILE: src-tauri/src/mcp/tool_impl/mod.rs
// IMPORTANT NOTE: Create this new file.
// This module will contain the actual implementations of the tool logic
// that the MCP handler will call. These implementations will use Tauri plugins.

pub mod filesystem;
pub mod ripgrep;
pub mod terminal;
pub mod process; 
pub mod edit;
</file>

<file path="src-tauri/src/utils/audit_logger.rs">
// FILE: src-tauri/src/utils/audit_logger.rs
// IMPORTANT NOTE: Rewrite the entire file.
use crate::config::Config;
use anyhow::Result;
use chrono::Utc;
use serde_json::Value;
use std::path::PathBuf;
use std::sync::{Arc, RwLock as StdRwLock};
use tauri::State;
use tokio::fs::{self, OpenOptions};
use tokio::io::AsyncWriteExt;
use tracing::error;

#[derive(Debug)]
pub struct AuditLogger {
    log_file_path: PathBuf,
    max_size_bytes: u64,
}

impl AuditLogger {
    pub fn new(config_state: Arc<StdRwLock<Config>>) -> Self {
        let config_guard = config_state.read().unwrap();
        let log_file_path = config_guard.audit_log_file.clone();
        let max_size_bytes = config_guard.audit_log_max_size_bytes;
        drop(config_guard);

        if let Some(parent_dir) = log_file_path.parent() {
            if !parent_dir.exists() {
                if let Err(e) = std::fs::create_dir_all(parent_dir) {
                    error!(path = %parent_dir.display(), error = %e, "Failed to create audit log directory");
                }
            }
        }
        Self {
            log_file_path,
            max_size_bytes,
        }
    }

    async fn rotate_log_if_needed(&self) -> Result<()> {
        if !self.log_file_path.exists() {
            return Ok(());
        }

        let metadata = fs::metadata(&self.log_file_path).await?;
        if metadata.len() >= self.max_size_bytes {
            let timestamp = Utc::now().format("%Y-%m-%d_%H-%M-%S").to_string();
            let file_stem = self
                .log_file_path
                .file_stem()
                .unwrap_or_default()
                .to_string_lossy();
            let extension = self
                .log_file_path
                .extension()
                .unwrap_or_default()
                .to_string_lossy();

            let backup_file_name = format!("{}_{}.{}", file_stem, timestamp, extension);
            let backup_path = self.log_file_path.with_file_name(backup_file_name);

            fs::rename(&self.log_file_path, backup_path).await?;
        }
        Ok(())
    }

    pub async fn log_command_call(&self, command_name: &str, arguments: &Value) {
        if let Err(e) = self.try_log_command_call(command_name, arguments).await {
            error!(command = %command_name, error = %e, "Failed to write audit log");
        }
    }

    async fn try_log_command_call(&self, command_name: &str, arguments: &Value) -> Result<()> {
        self.rotate_log_if_needed().await?;

        let timestamp = Utc::now().to_rfc3339();

        let mut sanitized_args = arguments.clone();
        if let Some(obj) = sanitized_args.as_object_mut() {
            for key_to_sanitize in ["content", "old_string", "new_string", "command", "pattern"] { // Added "pattern"
                if let Some(val_mut) = obj.get_mut(key_to_sanitize) {
                    if val_mut.is_string() && val_mut.as_str().unwrap_or("").len() > 256 {
                        *val_mut = Value::String(format!("<{} truncated for log>", key_to_sanitize));
                    }
                }
            }
        }

        let args_string = serde_json::to_string(&sanitized_args)?;
        let log_entry = format!("{} | CMD: {:<25} | Arguments: {}\n", timestamp, command_name, args_string);

        let mut file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file_path)
            .await?;

        file.write_all(log_entry.as_bytes()).await?;
        Ok(())
    }
}

pub async fn audit_log(
    logger_state: &State<'_, Arc<AuditLogger>>, // Borrow State directly
    command_name: &str,
    arguments: &Value,
) {
    logger_state.inner().log_command_call(command_name, arguments).await;
}
</file>

<file path="src-tauri/src/utils/fuzzy_search_logger.rs">
// FILE: src-tauri/src/utils/fuzzy_search_logger.rs
// IMPORTANT NOTE: Rewrite the entire file.
use crate::config::Config;
use anyhow::Result;
use chrono::Utc;
use serde::Serialize;
use std::path::PathBuf;
use std::sync::{Arc, RwLock as StdRwLock};
use tokio::fs::{self, OpenOptions};
use tokio::io::AsyncWriteExt;
use tokio::sync::Mutex as TokioMutex;
use tracing::error;

#[derive(Debug, Serialize)]
pub struct FuzzySearchLogEntry {
    pub timestamp: chrono::DateTime<Utc>,
    pub search_text: String,
    pub found_text: String,
    pub similarity: f64,
    pub execution_time_ms: f64,
    pub exact_match_count: usize,
    pub expected_replacements: usize,
    pub fuzzy_threshold: f64,
    pub below_threshold: bool,
    pub diff: String,
    pub search_length: usize,
    pub found_length: usize,
    pub file_extension: String,
    pub character_codes: String,
    pub unique_character_count: usize,
    pub diff_length: usize,
}

#[derive(Debug)]
pub struct FuzzySearchLogger {
    log_file_path: PathBuf,
    initialized: TokioMutex<bool>,
    max_size_bytes: u64,
}

impl FuzzySearchLogger {
    pub fn new(config_state: Arc<StdRwLock<Config>>) -> Self {
        let config_guard = config_state.read().unwrap();
        let log_file_path = config_guard.fuzzy_search_log_file.clone();
        let max_size_bytes = config_guard.audit_log_max_size_bytes; // Reuse audit log size for now
        drop(config_guard);

        if let Some(parent_dir) = log_file_path.parent() {
            if !parent_dir.exists() {
                if let Err(e) = std::fs::create_dir_all(parent_dir) {
                    error!(path = %parent_dir.display(), error = %e, "Failed to create fuzzy search log directory");
                }
            }
        }
        Self {
            log_file_path,
            initialized: TokioMutex::new(false),
            max_size_bytes,
        }
    }

    async fn rotate_log_if_needed(&self) -> Result<()> {
        if !self.log_file_path.exists() {
            return Ok(());
        }
        let metadata = fs::metadata(&self.log_file_path).await?;
        if metadata.len() >= self.max_size_bytes {
            let timestamp = Utc::now().format("%Y-%m-%d_%H-%M-%S").to_string();
            let file_stem = self.log_file_path.file_stem().unwrap_or_default().to_string_lossy();
            let extension = self.log_file_path.extension().unwrap_or_default().to_string_lossy();
            let backup_file_name = format!("{}_{}.{}", file_stem, timestamp, extension);
            let backup_path = self.log_file_path.with_file_name(backup_file_name);
            fs::rename(&self.log_file_path, backup_path).await?;
            let mut initialized_guard = self.initialized.lock().await;
            *initialized_guard = false; // Force re-initialization of headers
        }
        Ok(())
    }

    async fn ensure_log_file_initialized(&self) -> Result<()> {
        let mut initialized_guard = self.initialized.lock().await;
        if *initialized_guard {
            return Ok(());
        }

        let exists = match tokio::fs::metadata(&self.log_file_path).await {
            Ok(_) => true,
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => false,
            Err(e) => return Err(e.into()),
        };

        if !exists {
            let headers = [
                "timestamp", "searchText", "foundText", "similarity",
                "executionTime_ms", "exactMatchCount", "expectedReplacements",
                "fuzzyThreshold", "belowThreshold", "diff", "searchLength",
                "foundLength", "fileExtension", "characterCodes",
                "uniqueCharacterCount", "diffLength",
            ].join("\t");
            let mut file = OpenOptions::new()
                .create(true)
                .write(true)
                .open(&self.log_file_path)
                .await?;
            file.write_all(format!("{}\n", headers).as_bytes()).await?;
        }
        *initialized_guard = true;
        Ok(())
    }

    pub async fn log(&self, entry: &FuzzySearchLogEntry) {
        if let Err(e) = self.try_log(entry).await {
            error!(error = %e, "Failed to write fuzzy search log");
        }
    }

    async fn try_log(&self, entry: &FuzzySearchLogEntry) -> Result<()> {
        self.rotate_log_if_needed().await?;
        self.ensure_log_file_initialized().await?;

        let escape = |s: &str| s.replace('\t', "\\t").replace('\n', "\\n").replace('\r', "\\r");

        let log_line = format!(
            "{}\t{}\t{}\t{:.4}\t{:.2}\t{}\t{}\t{:.2}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
            entry.timestamp.to_rfc3339(),
            escape(&entry.search_text),
            escape(&entry.found_text),
            entry.similarity,
            entry.execution_time_ms,
            entry.exact_match_count,
            entry.expected_replacements,
            entry.fuzzy_threshold,
            entry.below_threshold,
            escape(&entry.diff),
            entry.search_length,
            entry.found_length,
            escape(&entry.file_extension),
            escape(&entry.character_codes),
            entry.unique_character_count,
            entry.diff_length
        );

        let mut file = OpenOptions::new()
            .append(true)
            .open(&self.log_file_path)
            .await?;
        file.write_all(log_line.as_bytes()).await?;
        Ok(())
    }
}
</file>

<file path="src-tauri/src/utils/line_ending_handler.rs">
// FILE: src-tauri/src/utils/line_ending_handler.rs
// IMPORTANT NOTE: Rewrite the entire file.
use tracing::debug;

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize)]
pub enum LineEndingStyle {
    Lf,
    CrLf,
    Cr,
    Mixed,
    Unknown,
}

impl LineEndingStyle {
    pub fn as_str(&self) -> &'static str {
        match self {
            LineEndingStyle::Lf => "\n",
            LineEndingStyle::CrLf => "\r\n",
            LineEndingStyle::Cr => "\r",
            LineEndingStyle::Mixed | LineEndingStyle::Unknown => {
                if cfg!(windows) { "\r\n" } else { "\n" }
            }
        }
    }
}

pub fn detect_line_ending(content: &str) -> LineEndingStyle {
    if content.is_empty() {
        return LineEndingStyle::Unknown;
    }

    let mut lf_count = 0;
    let mut crlf_count = 0;
    let mut cr_count = 0;

    let mut i = 0;
    let bytes = content.as_bytes();
    let len = bytes.len();

    while i < len {
        if bytes[i] == b'\r' {
            if i + 1 < len && bytes[i + 1] == b'\n' {
                crlf_count += 1;
                i += 2;
            } else {
                cr_count += 1;
                i += 1;
            }
        } else if bytes[i] == b'\n' {
            lf_count += 1;
            i += 1;
        } else {
            i += 1;
        }
    }
    
    debug!(lf=lf_count, crlf=crlf_count, cr=cr_count, "Detected line ending counts");

    if crlf_count > 0 && lf_count == 0 && cr_count == 0 {
        return LineEndingStyle::CrLf;
    }
    if lf_count > 0 && crlf_count == 0 && cr_count == 0 {
        return LineEndingStyle::Lf;
    }
    if cr_count > 0 && crlf_count == 0 && lf_count == 0 {
        return LineEndingStyle::Cr;
    }
    
    if crlf_count == 0 && lf_count == 0 && cr_count == 0 {
        return LineEndingStyle::Unknown;
    }

    if crlf_count >= lf_count && crlf_count >= cr_count {
        return LineEndingStyle::CrLf;
    }
    if lf_count >= crlf_count && lf_count >= cr_count {
        return LineEndingStyle::Lf;
    }
    return LineEndingStyle::Cr;
}

pub fn normalize_line_endings(text: &str, target_style: LineEndingStyle) -> String {
    let effective_target_style = match target_style {
        LineEndingStyle::Unknown | LineEndingStyle::Mixed => {
            if cfg!(windows) { LineEndingStyle::CrLf } else { LineEndingStyle::Lf }
        },
        _ => target_style,
    };

    let normalized_to_lf = text.replace("\r\n", "\n").replace('\r', "\n");

    match effective_target_style {
        LineEndingStyle::Lf => normalized_to_lf,
        LineEndingStyle::CrLf => normalized_to_lf.replace('\n', "\r\n"),
        LineEndingStyle::Cr => normalized_to_lf.replace('\n', "\r"),
        _ => normalized_to_lf,
    }
}
</file>

<file path="src/app/page.tsx">
// FILE: src/app/page.tsx
// IMPORTANT NOTE: Rewrite the entire file.
"use client";
import { RoundedButton } from "@/components/RoundedButton"; // Assuming this is a custom button
import { invoke } from "@tauri-apps/api/core";
import Image from "next/image";
import Link from "next/link"; // For navigation
import { useCallback, useState } from "react";
import { Button } from "@/components/ui/button"; // Assuming Shadcn UI Button

export default function Home() {
  const [greetMsg, setGreetMsg] = useState<string | null>(
    "Click the button to call a Rust function!",
  );
  const [isLoading, setIsLoading] = useState(false);

  const callGreet = useCallback(async () => {
    setIsLoading(true);
    try {
      const result = await invoke<string>("greet"); // Ensure 'greet' is registered in lib.rs
      setGreetMsg(result);
    } catch (error) {
      console.error("Error invoking greet:", error);
      setGreetMsg(`Error: ${error instanceof Error ? error.message : String(error)}`);
    } finally {
      setIsLoading(false);
    }
  }, []);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 font-[family-name:var(--font-geist-sans)]">
      <header className="mb-8 text-center">
        <Image
          className="dark:invert mx-auto mb-4"
          src="/next.svg" // Assuming this is in public folder
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <h1 className="text-4xl font-bold">MCP-RG-Editor (Tauri Edition)</h1>
        <p className="text-lg text-muted-foreground">
          Enhanced Desktop Commander with Ripgrep, Filesystem, and Terminal tools.
        </p>
      </header>

      <nav className="mb-8">
        <Link href="/config" passHref>
          <Button variant="outline">Go to Configuration Page</Button>
        </Link>
      </nav>

      <section className="w-full max-w-md p-6 space-y-4 bg-card text-card-foreground rounded-lg shadow-md">
        <h2 className="text-2xl font-semibold">Test Backend Connection</h2>
        <p className="text-sm text-muted-foreground">
          {greetMsg}
        </p>
        <Button onClick={callGreet} disabled={isLoading} className="w-full">
          {isLoading ? "Calling..." : 'Call "greet" from Rust'}
        </Button>
      </section>

      <footer className="mt-12 text-center text-sm text-muted-foreground">
        <p>Powered by Tauri & Next.js</p>
        <div className="flex justify-center gap-4 mt-2">
          <a
            href="https://nextjs.org/docs"
            target="_blank"
            rel="noopener noreferrer"
            className="hover:underline"
          >
            Next.js Docs
          </a>
          <a
            href="https://tauri.app/v2/api/js/"
            target="_blank"
            rel="noopener noreferrer"
            className="hover:underline"
          >
            Tauri JS API
          </a>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src-tauri/Cargo.toml">
[package]
name = "mcp-rg-editor-tauri"
version = "0.1.0"
description = "Desktop Commander Enhanced - Tauri Edition (MCP Server)"
authors = ["Babybird"]
edition = "2021"
rust-version = "1.70"

[lib]
name = "mcp_rg_editor_tauri_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2.0.0-beta.20", features = [] }

[dependencies]
# Tauri Core & Essential Plugins
tauri = { version = "2.5.1", features = ["devtools"] }
tauri-plugin-fs = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }
tauri-plugin-shell = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }
tauri-plugin-process = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }
tauri-plugin-http = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }
tauri-plugin-dialog = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }
tauri-plugin-log = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }
tauri-plugin-notification = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v2" }

# MCP SDK Dependencies
rust-mcp-sdk = "0.2.6" # As per your provided rust-mcp-sdk-llms.txt
rust-mcp-schema = "0.4.0" # As per your provided rust-mcp-sdk-llms.txt
rust-mcp-transport = "0.2.3" # As per your provided rust-mcp-sdk-llms.txt
async-trait = "0.1.80" # Updated version, check compatibility if issues arise

# Serde
serde = { version = "1.0.203", features = ["derive"] }
serde_json = "1.0.117"

# Error Handling
thiserror = "1.0.63"
anyhow = "1.0.86"

# Configuration & Logging
dotenvy = "0.15.7"
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter", "json", "fmt"] }

# Utilities from original mcp-rg-editor (ensure versions are compatible)
which = "6.0.1"
uuid = { version = "1.10.0", features = ["v4", "serde"] }
strsim = "0.11.1"
sysinfo = "0.30.12" # Check for API changes from 0.35.1
regex = "1.10.5"
shellexpand = "3.1.0"
chrono = { version = "0.4.38", features = ["serde"] }
reqwest = { version = "0.12.5", features = ["json", "stream"] } # May still be useful for some URL tasks
base64 = "0.22.1"
mime_guess = "2.0.5"
diff = "0.1.13"
dunce = "1.0.4"
tokio = { version = "1.38.1", features = ["full"] }
once_cell = "1.19.0"

# For MCP SSE Server (if enabled)
axum = { version = "0.7.5", optional = true } # rust-mcp-sdk might bring its own hyper/axum
hyper = { version = "1.4.1", features = ["full"], optional = true }
tower-http = { version = "0.5.2", features = ["fs", "trace", "cors"], optional = true }


[features]
default = ["custom-protocol", "mcp-stdio-server"] # Default to STDIO MCP server
custom-protocol = ["tauri/custom-protocol"]

# MCP Server features
mcp-stdio-server = []
mcp-sse-server = ["axum", "hyper", "tower-http", "rust-mcp-sdk/hyper-server"] # Enable if SSE transport is desired for MCP

[profile.release]
panic = "abort"
codegen-units = 1
lto = true
opt-level = "s"
strip = true
</file>

<file path="src-tauri/src/commands/config_commands.rs">
use crate::config::{Config, expand_tilde};
use crate::error::AppError;
use crate::utils::audit_logger::audit_log;

use serde_json::Value;
use std::path::PathBuf;
use std::sync::{Arc, RwLock as StdRwLock};
use tauri::{AppHandle, State};
use tracing::{info, warn};


#[derive(serde::Deserialize, serde::Serialize)]
pub struct SetConfigValuePayload {
    key: String,
    value: Value,
}

#[tauri::command(async)]
pub async fn get_config_command(
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
) -> Result<Config, String> {
    audit_log(&audit_logger_state, "ui_get_config", &serde_json::Value::Null).await;

    let config_guard = config_state.read().map_err(|e| {
        AppError::ConfigError(format!("Failed to acquire read lock on config: {}", e)).to_string()
    })?;
    Ok(config_guard.clone())
}

#[tauri::command(async)]
pub async fn set_config_value_command(
    _app_handle: AppHandle,
    payload: SetConfigValuePayload,
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
) -> Result<String, String> {
    audit_log(&audit_logger_state, "ui_set_config_value", &serde_json::to_value(&payload).unwrap_or_default()).await;

    let mut config_guard = config_state.write().map_err(|e| {
        AppError::ConfigError(format!("Failed to acquire write lock on config: {}", e)).to_string()
    })?;

    let key = payload.key.as_str();
    let value_to_set = payload.value;
    // let mut _update_applied = true; // No longer strictly needed due to early returns

    info!(key = %key, value = ?value_to_set, "UI: Attempting to set config value");

    match key {
        "allowedDirectories" => {
            let new_dirs_str_values: Vec<String> = match value_to_set {
                Value::Array(arr_val) => arr_val.into_iter().filter_map(|v| v.as_str().map(String::from)).collect(),
                Value::String(str_val) => str_val.split(',').map(|s| s.trim().to_string()).filter(|s| !s.is_empty()).collect(),
                _ => return Err(AppError::InvalidInputArgument("allowedDirectories must be a JSON array of strings or a comma-separated string".to_string()).to_string()),
            };

            let mut new_dirs_pathbuf = Vec::new();
            for s_path in new_dirs_str_values {
                if s_path.is_empty() { continue; }
                match expand_tilde(&s_path) {
                    Ok(p) => new_dirs_pathbuf.push(p.canonicalize().unwrap_or(p)),
                    Err(e) => return Err(AppError::InvalidPath(format!("Invalid path in allowedDirectories '{}': {}", s_path, e)).to_string()),
                }
            }

            let is_files_root_broad = config_guard.files_root == PathBuf::from("/") ||
                                    (cfg!(windows) && config_guard.files_root.parent().is_none() && config_guard.files_root.is_absolute());
            if !is_files_root_broad && !new_dirs_pathbuf.iter().any(|ad| ad == &config_guard.files_root) {
                new_dirs_pathbuf.push(config_guard.files_root.clone());
            }
            new_dirs_pathbuf.sort();
            new_dirs_pathbuf.dedup();
            config_guard.allowed_directories = new_dirs_pathbuf;
            info!(new_allowed_dirs = ?config_guard.allowed_directories, "Updated allowedDirectories");
        },
        "blockedCommands" => {
            let new_cmds: Vec<String> = match value_to_set {
                Value::Array(arr_val) => arr_val.into_iter().filter_map(|v| v.as_str().map(String::from)).collect(),
                Value::String(str_val) => str_val.split(',').map(|s| s.trim().to_string()).filter(|s| !s.is_empty()).collect(),
                _ => return Err(AppError::InvalidInputArgument("blockedCommands must be a JSON array of strings or a comma-separated string".to_string()).to_string()),
            };
            config_guard.blocked_commands = new_cmds;
            info!(new_blocked_cmds = ?config_guard.blocked_commands, "Updated blockedCommands");
        },
        "defaultShell" => {
            if let Some(str_val) = value_to_set.as_str() {
                config_guard.default_shell = if str_val.trim().is_empty() { None } else { Some(str_val.trim().to_string()) };
            } else if value_to_set.is_null() {
                 config_guard.default_shell = None;
            } else {
                warn!(key=key, "set_config_value: value for defaultShell was not a string or null");
                 return Err(AppError::InvalidInputArgument(format!("Invalid value type for config key '{}'", key)).to_string());
            }
            info!(new_default_shell = ?config_guard.default_shell, "Updated defaultShell");
        },
        "logLevel" => {
            if let Some(str_val) = value_to_set.as_str() {
                config_guard.log_level = str_val.to_string();
                warn!("Log level set to '{}' in config. A full application restart may be needed for tracing subscriber changes to take complete effect.", str_val);
            } else {
                warn!(key=key, "set_config_value: value for logLevel was not a string");
                return Err(AppError::InvalidInputArgument(format!("Invalid value type for config key '{}'", key)).to_string());
            }
            info!(new_log_level = %config_guard.log_level, "Updated logLevel");
        },
        "fileReadLineLimit" => {
            if let Some(num_val) = value_to_set.as_u64() {
                config_guard.file_read_line_limit = num_val as usize;
            } else {
                warn!(key=key, "set_config_value: value for fileReadLineLimit was not u64");
                return Err(AppError::InvalidInputArgument(format!("Invalid value type for config key '{}'", key)).to_string());
            }
            info!(new_read_limit = %config_guard.file_read_line_limit, "Updated fileReadLineLimit");
        },
         "fileWriteLineLimit" => {
            if let Some(num_val) = value_to_set.as_u64() {
                config_guard.file_write_line_limit = num_val as usize;
            } else {
                warn!(key=key, "set_config_value: value for fileWriteLineLimit was not u64");
                 return Err(AppError::InvalidInputArgument(format!("Invalid value type for config key '{}'", key)).to_string());
            }
            info!(new_write_limit = %config_guard.file_write_line_limit, "Updated fileWriteLineLimit");
        },
        "filesRoot" | "mcpLogDir" | "auditLogFile" | "fuzzySearchLogFile" => {
             warn!(key=key, "set_config_value: Dynamically changing this path is not supported via this command.");
             return Err(AppError::ConfigError(format!("Configuration key '{}' cannot be changed at runtime through this command.", key)).to_string());
        }
        _ => {
            warn!(key=key, "set_config_value: Unknown or unhandled config key");
            return Err(AppError::InvalidInputArgument(format!("Unknown or read-only config key: {}", key)).to_string());
        }
    }

    info!(key = %key, "Successfully set config value via UI command");
    Ok(format!("Successfully set config key '{}'. Changes are in-memory for the current session.", key))
}
</file>

<file path="src-tauri/src/commands/edit_commands.rs">
// This file's commands are now largely superseded by MCP tools.
// For this iteration, this file will be empty of commands, assuming MCP is the primary interface.
// If UI needs direct calls to edit logic not via MCP, define them here.
// Example:
/*
use crate::config::Config;
use crate::error::AppError;
use crate::utils::audit_logger::audit_log;
use crate::mcp::tool_impl::edit as mcp_edit_impl;
use crate::mcp::handler::ToolDependencies;

use std::sync::{Arc, RwLock as StdRwLock};
use tauri::{AppHandle, Manager, State};
use sysinfo::System as SysinfoSystem;
use tokio::sync::Mutex as TokioMutex;

pub use crate::mcp::tool_impl::edit::EditBlockParamsMCP as EditBlockParams;
pub use crate::mcp::tool_impl::edit::EditBlockResultMCP as EditBlockResult;

fn get_tool_dependencies_for_ui(app_handle: &AppHandle, config_state: &State<'_, Arc<StdRwLock<Config>>>) -> ToolDependencies {
    ToolDependencies {
        app_handle: app_handle.clone(),
        config_state: config_state.inner().clone(),
        audit_logger: app_handle.state::<Arc<crate::utils::audit_logger::AuditLogger>>().inner().clone(),
        fuzzy_search_logger: app_handle.state::<Arc<crate::utils::fuzzy_search_logger::FuzzySearchLogger>>().inner().clone(),
        active_sessions_map: app_handle.state::<crate::commands::terminal_commands::ActiveSessionsMap>().inner().clone(),
        sysinfo_state: app_handle.state::<Arc<TokioMutex<SysinfoSystem>>>().inner().clone(),
    }
}

#[tauri::command(async)]
pub async fn edit_block_command_ui_wrapper( // Example wrapper
    app_handle: AppHandle,
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
    params: EditBlockParams,
) -> Result<EditBlockResult, AppError> {
    audit_log(&audit_logger_state, "ui_edit_block_wrapper", &serde_json::to_value(ms)?).await;
    let deps = get_tool_dependencies_for_ui(&app_handle, &config_state);
    mcp_edit_impl::mcp_edit_block(&deps, params).await
}
*/
</file>

<file path="src-tauri/src/commands/terminal_commands.rs">
// This file's commands are now largely superseded by MCP tools.
// The ActiveSession and ActiveSessionsMap types are still needed by the MCP terminal tool implementation.
// If UI needs direct calls to terminal logic not via MCP, define them here.
// For this iteration, this file will only contain the necessary type definitions.

use serde::Serialize;
use std::collections::HashMap;
use std::sync::Arc;
use tauri_plugin_shell::process::CommandChild;
use tokio::sync::Mutex as TokioMutex; // Keep TokioMutex for ActiveSession

#[derive(Debug, Clone, Serialize)]
pub struct ExecuteCommandResultUI { // Kept for potential direct UI use if needed later
    pub session_id: String,
    pub pid: Option<u32>,
    pub message: String,
}

#[derive(Debug)]
pub struct ActiveSession {
    pub process_child: Arc<TokioMutex<Option<CommandChild>>>,
    pub command_str: String,
    pub exit_code: Arc<TokioMutex<Option<i32>>>,
    pub start_time_system: std::time::SystemTime,
    pub session_id: String,
    pub pid: Option<u32>,
}

pub type ActiveSessionsMap = Arc<TokioMutex<HashMap<String, Arc<ActiveSession>>>>;

// UI-specific Tauri commands for terminal operations (e.g., execute_command_ui, 
// force_terminate_session_ui, list_sessions_ui, read_session_output_status_ui)
// would go here if they were not superseded by MCP tools.
// For now, they are removed to focus on the MCP implementation.
</file>

<file path="src-tauri/src/mcp/schemas.rs">
use rust_mcp_schema::ToolInputSchema;
use serde_json::{json, Value, Map};
use std::collections::HashMap;

fn create_prop(type_str: &str, description: &str) -> Value {
    json!({ "type": type_str, "description": description })
}
fn create_prop_with_default_bool(type_str: &str, description: &str, default_val: bool) -> Value {
    json!({ "type": type_str, "description": description, "default": default_val })
}
fn create_prop_with_default_int(type_str: &str, description: &str, default_val: usize) -> Value {
    json!({ "type": type_str, "description": description, "default": default_val })
}
fn create_prop_with_default_str(type_str: &str, description: &str, default_val: &str) -> Value {
    json!({ "type": type_str, "description": description, "default": default_val })
}
fn create_array_prop(item_type_str: &str, description: &str) -> Value {
    json!({ "type": "array", "items": { "type": item_type_str }, "description": description })
}
fn create_enum_prop(enum_values: Vec<&str>, default_value: &str, description: &str) -> Value {
    json!({ "type": "string", "enum": enum_values, "default": default_value, "description": description })
}

const MCP_PATH_GUIDANCE: &str = "IMPORTANT: Paths should be absolute or tilde-expanded (~/...). The server will resolve them against its configured FILES_ROOT if relative, but absolute/tilde is preferred for clarity.";

fn value_to_map(value: Value) -> Map<String, Value> {
    match value {
        Value::Object(map) => map,
        _ => Map::new(), 
    }
}

fn props_to_tool_input_schema_props(props: HashMap<String, Value>) -> Option<HashMap<String, Map<String, Value>>> {
    if props.is_empty() {
        None
    } else {
        Some(props.into_iter().map(|(k, v)| (k, value_to_map(v))).collect())
    }
}

fn create_tool_input_schema(
    required_props: Vec<String>,
    props_map: HashMap<String, Value>
) -> ToolInputSchema {
    ToolInputSchema {
        type_: "object".to_string(),
        required: if required_props.is_empty() { None } else { Some(required_props) },
        properties: props_to_tool_input_schema_props(props_map),
        meta: None,
    }
}

// --- MCP Tool Schemas ---
pub fn get_mcp_config_schema() -> ToolInputSchema {
    create_tool_input_schema(vec![], HashMap::new())
}

pub fn read_file_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("path".to_string(), create_prop("string", &format!("Path to the file or URL. {}", MCP_PATH_GUIDANCE)));
    props.insert("is_url".to_string(), create_prop_with_default_bool("boolean", "True if 'path' is a URL.", false));
    props.insert("offset".to_string(), create_prop_with_default_int("integer", "Line offset for text files.", 0));
    props.insert("length".to_string(), json!({"type": "integer", "description": "Max lines to read for text files. Server default if not provided."}));
    let req = vec!["path".to_string()];
    create_tool_input_schema(req, props)
}

pub fn write_file_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("path".to_string(), create_prop("string", &format!("File path. {}", MCP_PATH_GUIDANCE)));
    props.insert("content".to_string(), create_prop("string", "Content to write."));
    props.insert("mode".to_string(), create_enum_prop(vec!["rewrite", "append"], "rewrite", "Write mode."));
    let req = vec!["path".to_string(), "content".to_string()];
    create_tool_input_schema(req, props)
}

pub fn create_directory_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("path".to_string(), create_prop("string", &format!("Directory path to create. {}", MCP_PATH_GUIDANCE)));
    let req = vec!["path".to_string()];
    create_tool_input_schema(req, props)
}

pub fn list_directory_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("path".to_string(), create_prop("string", &format!("Directory path to list. {}", MCP_PATH_GUIDANCE)));
    let req = vec!["path".to_string()];
    create_tool_input_schema(req, props)
}

pub fn move_file_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("source".to_string(), create_prop("string", &format!("Source path. {}", MCP_PATH_GUIDANCE)));
    props.insert("destination".to_string(), create_prop("string", &format!("Destination path. {}", MCP_PATH_GUIDANCE)));
    let req = vec!["source".to_string(), "destination".to_string()];
    create_tool_input_schema(req, props)
}

pub fn get_file_info_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("path".to_string(), create_prop("string", &format!("File/directory path. {}", MCP_PATH_GUIDANCE)));
    let req = vec!["path".to_string()];
    create_tool_input_schema(req, props)
}

pub fn read_multiple_files_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("paths".to_string(), create_array_prop("string", &format!("Array of file paths. {}", MCP_PATH_GUIDANCE)));
    let req = vec!["paths".to_string()];
    create_tool_input_schema(req, props)
}

pub fn search_files_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("path".to_string(), create_prop("string", &format!("Root path for search. {}", MCP_PATH_GUIDANCE)));
    props.insert("pattern".to_string(), create_prop("string", "Search pattern for file/dir names."));
    props.insert("timeoutMs".to_string(), json!({"type": "integer", "description": "Timeout in ms. Default 30000."}));
    props.insert("recursive".to_string(), create_prop_with_default_bool("boolean", "Search recursively.", true));
    props.insert("max_depth".to_string(), create_prop_with_default_int("integer", "Max recursion depth.", 10));
    let req = vec!["path".to_string(), "pattern".to_string()];
    create_tool_input_schema(req, props)
}


pub fn search_code_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("pattern".to_string(), create_prop("string", "Ripgrep search pattern."));
    props.insert("path".to_string(), create_prop_with_default_str("string", &format!("Directory to search. Default: FILES_ROOT. {}", MCP_PATH_GUIDANCE), "."));
    props.insert("fixed_strings".to_string(), create_prop_with_default_bool("boolean", "Treat pattern as literal.", false));
    props.insert("ignore_case".to_string(), create_prop_with_default_bool("boolean", "Case-insensitive search.", false));
    props.insert("case_sensitive".to_string(), create_prop_with_default_bool("boolean", "Case-sensitive search.", false));
    props.insert("line_numbers".to_string(), create_prop_with_default_bool("boolean", "Include line numbers.", true));
    props.insert("context_lines".to_string(), create_prop_with_default_int("integer", "Context lines around match.", 0));
    props.insert("file_pattern".to_string(), json!({"type": "string", "description": "Glob to filter files (e.g., \"*.rs\")."}));
    props.insert("max_depth".to_string(), json!({"type": "integer", "description": "Max search depth."}));
    props.insert("max_results".to_string(), create_prop_with_default_int("integer", "Max matches to return.", 1000));
    props.insert("include_hidden".to_string(), create_prop_with_default_bool("boolean", "Search hidden files/dirs.", false));
    props.insert("timeoutMs".to_string(), json!({"type": "integer", "description": "Timeout in ms. Default 30000."}));
    let req = vec!["pattern".to_string()];
    create_tool_input_schema(req, props)
}

pub fn execute_command_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("command".to_string(), create_prop("string", "Command to execute."));
    props.insert("timeout_ms".to_string(), create_prop_with_default_int("integer", "Timeout for initial output (ms).", 1000));
    props.insert("shell".to_string(), json!({"type": "string", "description": "Specific shell (e.g., bash, powershell). Server default if not set."}));
    let req = vec!["command".to_string()];
    create_tool_input_schema(req, props)
}

pub fn force_terminate_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("session_id".to_string(), create_prop("string", "ID of command session to terminate."));
    let req = vec!["session_id".to_string()];
    create_tool_input_schema(req, props)
}

pub fn list_sessions_mcp_schema() -> ToolInputSchema {
    create_tool_input_schema(vec![], HashMap::new())
}

pub fn read_session_output_status_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("session_id".to_string(), create_prop("string", "ID of command session."));
    let req = vec!["session_id".to_string()];
    create_tool_input_schema(req, props)
}

pub fn list_processes_mcp_schema() -> ToolInputSchema {
    create_tool_input_schema(vec![], HashMap::new())
}

pub fn kill_process_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("pid".to_string(), create_prop("integer", "Process ID (PID) to terminate."));
    let req = vec!["pid".to_string()];
    create_tool_input_schema(req, props)
}

pub fn edit_block_mcp_schema() -> ToolInputSchema {
    let mut props = HashMap::new();
    props.insert("file_path".to_string(), create_prop("string", &format!("File path. {}", MCP_PATH_GUIDANCE)));
    props.insert("old_string".to_string(), create_prop("string", "Exact string to replace."));
    props.insert("new_string".to_string(), create_prop("string", "String to replace with."));
    props.insert("expected_replacements".to_string(), create_prop_with_default_int("integer", "Expected number of replacements (0 for all).", 1));
    let req = vec!["file_path".to_string(), "old_string".to_string(), "new_string".to_string()];
    create_tool_input_schema(req, props)
}
</file>

<file path="src-tauri/src/mcp/tool_impl/edit.rs">
use crate::config::Config;
use crate::error::AppError;
use crate::mcp::handler::ToolDependencies;
use crate::utils::fuzzy_search_logger::FuzzySearchLogEntry;
use crate::utils::line_ending_handler::{detect_line_ending, normalize_line_endings, LineEndingStyle};
use crate::utils::path_utils::validate_and_normalize_path;

use serde::{Deserialize, Serialize};
use std::path::PathBuf;
// use std::sync::RwLockReadGuard; // No longer needed directly in this file's functions
// use tauri::AppHandle; // No longer needed directly
use tauri_plugin_fs::FsExt; // Added FsExt
use tracing::{debug, instrument, warn}; // Corrected warn import
use std::time::Instant;
use chrono::Utc;
use diff;

// --- MCP Specific Parameter Struct ---
#[derive(Debug, Deserialize, Serialize)]
pub struct EditBlockParamsMCP {
    pub file_path: String,
    pub old_string: String,
    pub new_string: String,
    #[serde(default = "default_one_usize_mcp")]
    pub expected_replacements: usize,
}
fn default_one_usize_mcp() -> usize { 1 }

// --- MCP Specific Result Structs ---
#[derive(Debug, Serialize)]
pub struct EditBlockResultMCP {
    pub file_path: String,
    pub replacements_made: usize,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fuzzy_match_details: Option<FuzzyMatchDetailsMCP>,
}
#[derive(Debug, Serialize)]
pub struct FuzzyMatchDetailsMCP {
    pub similarity_percent: f64,
    pub execution_time_ms: f64,
    pub diff_highlight: String,
    pub log_path_suggestion: String,
}

const FUZZY_SIMILARITY_THRESHOLD_MCP: f64 = 0.7;

async fn read_file_for_edit_mcp_internal(
    app_handle: &tauri::AppHandle,
    file_path_str: &str,
    config: &Config // Pass &Config
) -> Result<(String, PathBuf, LineEndingStyle), AppError> {
    // validate_and_normalize_path now takes &Config
    let path = validate_and_normalize_path(file_path_str, config, true, false)?;
    if !app_handle.fs_scope().is_allowed(&path) {
        return Err(AppError::PathNotAllowed(format!("Read denied by FS scope: {}", path.display())));
    }
    // Use app_handle.fs() for filesystem operations
    let original_content = app_handle.fs().read_text_file(&path).await
        .map_err(|e| AppError::PluginError{plugin:"fs".to_string(), message:format!("Failed to read text file {}: {}", path.display(), e)})?;
    Ok((original_content, path, detect_line_ending(&original_content)))
}


async fn write_file_after_edit_mcp(
    app_handle: &tauri::AppHandle,
    path_obj: &PathBuf,
    content: String
) -> Result<(), AppError> {
    if !app_handle.fs_scope().is_allowed(path_obj) {
        return Err(AppError::PathNotAllowed(format!("Write denied by FS scope: {}", path_obj.display())));
    }
    // Use app_handle.fs() for filesystem operations
    app_handle.fs().write_text_file(path_obj, content).await
        .map_err(|e| AppError::PluginError{plugin:"fs".to_string(), message:format!("Failed to write text file {}: {}", path_obj.display(), e)})
}


#[instrument(skip(deps, params), fields(file_path = %params.file_path))]
pub async fn mcp_edit_block(
    deps: &ToolDependencies,
    params: EditBlockParamsMCP
) -> Result<EditBlockResultMCP, AppError> {
    if params.old_string.is_empty() { return Err(AppError::EditError("old_string cannot be empty.".into())); }

    let (original_content, validated_path, file_line_ending, fuzzy_log_path, _files_root_for_log) = { // _files_root_for_log marked unused
        let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
        // Pass &*config_guard to get &Config
        let (content, path, ending) = read_file_for_edit_mcp_internal(&deps.app_handle, &params.file_path, &*config_guard).await?;
        (content, path, ending, config_guard.fuzzy_search_log_file.clone(), config_guard.files_root.clone())
    };
    
    let file_ext = validated_path.extension().unwrap_or_default().to_string_lossy().to_lowercase();

    let norm_old = normalize_line_endings(&params.old_string, file_line_ending);
    let norm_new = normalize_line_endings(&params.new_string, file_line_ending);
    let occurrences: Vec<_> = original_content.match_indices(&norm_old).collect();
    let actual_occurrences = occurrences.len();

    if (params.expected_replacements > 0 && actual_occurrences == params.expected_replacements) ||
       (params.expected_replacements == 0 && actual_occurrences > 0) {
        let new_content = original_content.replace(&norm_old, &norm_new);
        write_file_after_edit_mcp(&deps.app_handle, &validated_path, new_content).await?;
        let msg_key = if params.expected_replacements == 0 {"all occurrences"} else {"exact replacement(s)"};
        return Ok(EditBlockResultMCP {
            file_path: params.file_path,
            replacements_made: actual_occurrences,
            message: format!("Successfully applied {} {}.", actual_occurrences, msg_key),
            fuzzy_match_details: None
        });
    }

    if actual_occurrences > 0 && params.expected_replacements > 0 && actual_occurrences != params.expected_replacements {
         return Err(AppError::EditError(format!(
            "Expected {} occurrences but found {}. Please verify 'old_string' for uniqueness or adjust 'expected_replacements'. To replace all {} occurrences, set expected_replacements to 0 or {}.",
            params.expected_replacements, actual_occurrences, actual_occurrences, actual_occurrences
        )));
    }

    debug!("No exact match or count mismatch. Attempting fuzzy search for MCP edit_block.");
    let fuzzy_start = Instant::now();
    let (best_match, similarity) = find_best_fuzzy_match_internal(&original_content, &norm_old);
    let fuzzy_time_ms = fuzzy_start.elapsed().as_secs_f64() * 1000.0;
    let diff_hl = highlight_differences_internal(&norm_old, &best_match);
    let char_data = get_character_code_data_internal(&norm_old, &best_match);

    let log_entry = FuzzySearchLogEntry {
        timestamp: Utc::now(), search_text: params.old_string.clone(), found_text: best_match.clone(), similarity,
        execution_time_ms: fuzzy_time_ms, exact_match_count: actual_occurrences, expected_replacements: params.expected_replacements,
        fuzzy_threshold: FUZZY_SIMILARITY_THRESHOLD_MCP, below_threshold: similarity < FUZZY_SIMILARITY_THRESHOLD_MCP,
        diff: diff_hl.clone(), search_length: params.old_string.len(), found_length: best_match.len(),
        file_extension: file_ext.to_string(), character_codes: char_data.report,
        unique_character_count: char_data.unique_count, diff_length: char_data.diff_length,
    };
    let logger_clone = deps.fuzzy_search_logger.clone();
    tokio::spawn(async move { logger_clone.log(&log_entry).await; });

    let fuzzy_details = FuzzyMatchDetailsMCP {
        similarity_percent: similarity * 100.0, execution_time_ms: fuzzy_time_ms,
        diff_highlight: diff_hl.clone(), log_path_suggestion: fuzzy_log_path.display().to_string()
    };
    
    if similarity >= FUZZY_SIMILARITY_THRESHOLD_MCP {
        Ok(EditBlockResultMCP {
            file_path: params.file_path, replacements_made: 0,
            message: format!("Exact match not found. Similar text found ({:.2}% similarity). Review diff and provide exact text if replacement desired.", similarity * 100.0),
            fuzzy_match_details: Some(fuzzy_details)
        })
    } else {
        Err(AppError::EditError(format!("Search string not found. Closest fuzzy match {:.2}% (threshold {}%). Diff: {}", similarity * 100.0, FUZZY_SIMILARITY_THRESHOLD_MCP * 100.0, diff_hl)))
    }
}

fn find_best_fuzzy_match_internal(text: &str, query: &str) -> (String, f64) {
    if text.is_empty() || query.is_empty() { return ("".to_string(), 0.0); }
    let mut best_similarity = 0.0; let mut best_match_str = "";
    let text_chars: Vec<char> = text.chars().collect(); let text_len = text_chars.len();
    let query_len = query.chars().count(); if query_len == 0 { return ("".to_string(), 0.0); }
    let min_window_len = std::cmp::max(1, query_len.saturating_sub(query_len / 4));
    let max_window_len = std::cmp::min(text_len, query_len + query_len / 4);
    for window_len_chars in min_window_len..=max_window_len { if window_len_chars > text_len { continue; }
        for i in 0..=(text_len - window_len_chars) {
            let start_byte_idx = text.char_indices().nth(i).map(|(idx, _)| idx).unwrap_or(0);
            let end_byte_idx = text.char_indices().nth(i + window_len_chars).map(|(idx, _)| idx).unwrap_or_else(|| text.len());
            let window_str_slice = &text[start_byte_idx..end_byte_idx];
            let current_similarity = strsim::jaro_winkler(window_str_slice, query);
            if current_similarity > best_similarity { best_similarity = current_similarity; best_match_str = window_str_slice; }
            if best_similarity > 0.999 { return (best_match_str.to_string(), best_similarity); }
        }
    } (best_match_str.to_string(), best_similarity)
}
fn highlight_differences_internal(expected: &str, actual: &str) -> String {
    let diff_results = diff::chars(expected, actual); let mut result = String::new();
    for d_res in diff_results { match d_res {
        diff::Result::Left(l) => result.push_str(&format!("{{-{}-}}", l)),
        diff::Result::Both(l, _) => result.push(l),
        diff::Result::Right(r) => result.push_str(&format!("{{+{}+}}", r)),
    }} result
}
struct CharCodeDataInternal { report: String, unique_count: usize, diff_length: usize }
fn get_character_code_data_internal(expected: &str, actual: &str) -> CharCodeDataInternal {
    use std::collections::HashMap; let mut prefix_len = 0;
    let min_char_len = std::cmp::min(expected.chars().count(), actual.chars().count());
    let mut expected_chars_iter_prefix = expected.chars();
    let mut actual_chars_iter_prefix = actual.chars();
    for _ in 0..min_char_len { if expected_chars_iter_prefix.next() == actual_chars_iter_prefix.next() { prefix_len +=1; } else { break; }}
    
    let mut expected_chars_rev_iter = expected.chars().rev();
    let mut actual_chars_rev_iter = actual.chars().rev();
    let mut suffix_len = 0;
    for _ in 0..(min_char_len - prefix_len) { if expected_chars_rev_iter.next() == actual_chars_rev_iter.next() { suffix_len +=1; } else { break; }}
    
    let expected_diff_str: String = expected.chars().skip(prefix_len).take(expected.chars().count().saturating_sub(prefix_len).saturating_sub(suffix_len)).collect();
    let actual_diff_str: String = actual.chars().skip(prefix_len).take(actual.chars().count().saturating_sub(prefix_len).saturating_sub(suffix_len)).collect();
    
    let mut char_codes: HashMap<u32, usize> = HashMap::new();
    let full_diff_str = format!("{}{}", expected_diff_str, actual_diff_str);
    for ch in full_diff_str.chars() { *char_codes.entry(ch as u32).or_insert(0) += 1; }
    let mut report_parts: Vec<String> = char_codes.iter().map(|(&code, &count)| {
        let char_display = std::char::from_u32(code).map(|c| if c.is_control() || (c.is_whitespace() && c != ' ') { format!("\\x{:02x}", code) } else { c.to_string() }).unwrap_or_else(|| format!("\\u{{{:x}}}", code));
        format!("{}:{}[{}]", code, count, char_display)
    }).collect(); report_parts.sort();
    CharCodeDataInternal { report: report_parts.join(","), unique_count: char_codes.len(), diff_length: full_diff_str.chars().count() }
}
</file>

<file path="src-tauri/src/mcp/tool_impl/process.rs">
use crate::error::AppError;
use crate::mcp::handler::ToolDependencies;
use serde::{Deserialize, Serialize};
use sysinfo::{Pid, Signal, ProcessRefreshKind, Uid, System as SysinfoSystem}; // Keep SysinfoSystem import
use tokio::sync::MutexGuard; // Keep MutexGuard
use tracing::{debug, instrument, warn}; // Keep warn

// --- MCP Specific Parameter Structs ---
#[derive(Debug, Deserialize)]
pub struct KillProcessParamsMCP { pub pid: usize }

// --- MCP Specific Result Structs ---
#[derive(Debug, Serialize)]
pub struct ProcessInfoMCP {
    pid: String, name: String, cpu_usage: f32, memory_mb: u64,
    command: String, status: String, user: Option<String>, start_time_epoch_secs: u64,
}
#[derive(Debug, Serialize)]
pub struct KillProcessResultMCP { pub success: bool, pub message: String }

fn format_uid_mcp(uid_opt: Option<&Uid>) -> Option<String> {
    uid_opt.map(|uid| uid.to_string())
}

#[instrument(skip(deps))]
pub async fn mcp_list_processes(deps: &ToolDependencies) -> Result<Vec<ProcessInfoMCP>, AppError> {
    let mut sys_guard: MutexGuard<'_, SysinfoSystem> = deps.sysinfo_state.lock().await;
    sys_guard.refresh_processes_specifics(ProcessRefreshKind::everything());
    debug!("MCP Tool: Listing {} system processes.", sys_guard.processes().len());
    Ok(sys_guard.processes().iter().map(|(p, process)| ProcessInfoMCP {
        pid: p.as_u32().to_string(), name: process.name().to_string(), cpu_usage: process.cpu_usage(),
        memory_mb: process.memory() / (1024 * 1024), command: process.cmd().join(" "),
        status: process.status().to_string(), user: format_uid_mcp(process.user_id()),
        start_time_epoch_secs: process.start_time(),
    }).collect())
}

#[instrument(skip(deps, params), fields(pid = %params.pid))]
pub async fn mcp_kill_process(deps: &ToolDependencies, params: KillProcessParamsMCP) -> Result<KillProcessResultMCP, AppError> {
    let mut sys_guard: MutexGuard<'_, SysinfoSystem> = deps.sysinfo_state.lock().await;
    let pid_to_kill = Pid::from(params.pid);
    sys_guard.refresh_process_specifics(pid_to_kill, ProcessRefreshKind::everything());
    let proc_name = match sys_guard.process(pid_to_kill) {
        Some(p) => p.name().to_string(),
        None => return Ok(KillProcessResultMCP { success: false, message: format!("PID {} not found.", params.pid) }),
    };

    if let Some(p) = sys_guard.process(pid_to_kill) {
        if p.kill_with(Signal::Term).unwrap_or(false) {
            tokio::time::sleep(tokio::time::Duration::from_millis(200)).await; // Use tokio::time::Duration
            sys_guard.refresh_process_specifics(pid_to_kill, ProcessRefreshKind::everything());
            if sys_guard.process(pid_to_kill).is_none() { return Ok(KillProcessResultMCP { success: true, message: format!("PID {} ({}) terminated with SIGTERM.", params.pid, proc_name) }); }
            debug!(pid = ?pid_to_kill, "Process still alive after SIGTERM.");
        } else {
            debug!(pid = ?pid_to_kill, "Sending SIGTERM failed or process already gone.");
        }
    }

    sys_guard.refresh_process_specifics(pid_to_kill, ProcessRefreshKind::everything());
    if let Some(p) = sys_guard.process(pid_to_kill) {
        if p.kill_with(Signal::Kill).unwrap_or(false) {
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await; // Use tokio::time::Duration
            sys_guard.refresh_process_specifics(pid_to_kill, ProcessRefreshKind::everything());
            if sys_guard.process(pid_to_kill).is_none() { return Ok(KillProcessResultMCP { success: true, message: format!("PID {} ({}) terminated with SIGKILL.", params.pid, proc_name) }); }
            else {
                warn!(pid = ?pid_to_kill, "Process still running after SIGKILL.");
                return Ok(KillProcessResultMCP { success: false, message: format!("Sent SIGKILL to PID {} ({}), but it may still be running.", params.pid, proc_name) });
            }
        } else {
            warn!(pid = ?pid_to_kill, "Failed to send SIGKILL.");
            sys_guard.refresh_process_specifics(pid_to_kill, ProcessRefreshKind::everything());
            if sys_guard.process(pid_to_kill).is_none() {
                return Ok(KillProcessResultMCP { success: true, message: format!("PID {} ({}) no longer found after failed SIGKILL, likely terminated.", params.pid, proc_name) });
            }
            return Ok(KillProcessResultMCP { success: false, message: format!("Failed to send SIGKILL to PID {} ({}).", params.pid, proc_name) });
        }
    } else {
        debug!(pid = ?pid_to_kill, "Process not found before SIGKILL, assuming terminated.");
        return Ok(KillProcessResultMCP { success: true, message: format!("PID {} ({}) no longer found, likely terminated.", params.pid, proc_name) });
    }
}
</file>

<file path="src/app/config/page.tsx">
// FILE: src/app/config/page.tsx
// IMPORTANT NOTE: Rewrite the entire file.
"use client";

import { useEffect, useState, useCallback, ChangeEvent } from "react";
import { invoke } from "@tauri-apps/api/core";
// import { emit, listen } from "@tauri-apps/api/event"; // Not used in this version
import { toast } from "sonner";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Terminal } from "lucide-react"; // Assuming lucide-react is installed

// Matches the Rust Config struct (subset for UI interaction)
interface AppConfig {
  files_root: string;
  allowed_directories: string[];
  blocked_commands: string[];
  default_shell?: string | null;
  log_level: string;
  file_read_line_limit: number;
  file_write_line_limit: number;
  audit_log_file: string;
  fuzzy_search_log_file: string;
  mcp_log_dir: string;
}

interface EditableConfig {
  allowed_directories_str: string;
  blocked_commands_str: string;
  default_shell_str: string;
  log_level: string;
  file_read_line_limit_str: string;
  file_write_line_limit_str: string;
}

export default function ConfigPage() {
  const [config, setConfig] = useState<AppConfig | null>(null);
  const [editableConfig, setEditableConfig] = useState<EditableConfig>({
    allowed_directories_str: "",
    blocked_commands_str: "",
    default_shell_str: "",
    log_level: "info",
    file_read_line_limit_str: "1000",
    file_write_line_limit_str: "50",
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchConfig = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await invoke<AppConfig>("get_config_command");
      setConfig(result);
      setEditableConfig({
        allowed_directories_str: result.allowed_directories.join(", "),
        blocked_commands_str: result.blocked_commands.join(", "),
        default_shell_str: result.default_shell ?? "",
        log_level: result.log_level,
        file_read_line_limit_str: result.file_read_line_limit.toString(),
        file_write_line_limit_str: result.file_write_line_limit.toString(),
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      console.error("Failed to fetch config:", errorMessage);
      setError(errorMessage);
      toast.error(
        `Could not load configuration: ${errorMessage}`,
        { description: "Error Fetching Config" }
      );
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    void fetchConfig();
  }, [fetchConfig]);

  const handleInputChange = (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,
  ) => {
    const { name, value } = e.target;
    setEditableConfig((prev) => ({ ...prev, [name]: value }));
  };

  const handleSelectChange = (name: string, value: string) => {
    setEditableConfig((prev) => ({ ...prev, [name]: value }));
  };

  const handleSaveSetting = async (key: string, value: unknown) => {
    try {
      const result = await invoke<string>("set_config_value_command", {
        payload: { key, value },
      });
      toast.success(result || `Successfully updated ${key}.`, {
        description: "Setting Saved",
      });
      await fetchConfig();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      console.error(`Failed to save setting ${key}:`, errorMessage);
      toast.error(errorMessage, {
        description: `Error Saving ${key}`,
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        Loading configuration...
      </div>
    );
  }

  if (error && !config) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen p-4">
        <Alert variant="destructive" className="max-w-md">
          <Terminal className="h-4 w-4" />
          <AlertTitle>Failed to Load Configuration</AlertTitle>
          <AlertDescription>
            {error}
            <br />
            Please check the backend logs and ensure the application is running correctly.
            You might need to set environment variables like `FILES_ROOT`.
          </AlertDescription>
        </Alert>
        <Button onClick={() => { void fetchConfig(); }} className="mt-4">Retry</Button>
      </div>
    );
  }

  if (!config) {
     return (
      <div className="flex items-center justify-center min-h-screen p-4">
        No configuration data available. Ensure the backend is running and accessible.
      </div>
    );
  }

  return (
    <TooltipProvider>
      <div className="container mx-auto p-4 md:p-8 space-y-6">
        <header className="mb-8">
          <h1 className="text-3xl font-bold">Application Configuration</h1>
          <p className="text-muted-foreground">
            View and manage runtime settings. Some critical settings are read-only from environment variables.
          </p>
        </header>

        <Card>
          <CardHeader>
            <CardTitle>Core Settings (Read-only)</CardTitle>
            <CardDescription>
              Fundamental settings typically set via environment variables at startup.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label htmlFor="files_root">Files Root</Label>
              <Input id="files_root" value={config.files_root} readOnly />
               <p className="text-sm text-muted-foreground mt-1">
                The primary directory the application operates within. (Env: FILES_ROOT)
              </p>
            </div>
             <div>
              <Label htmlFor="mcp_log_dir">Log Directory</Label>
              <Input id="mcp_log_dir" value={config.mcp_log_dir} readOnly />
              <p className="text-sm text-muted-foreground mt-1">
                Directory for audit and fuzzy search logs. (Env: MCP_LOG_DIR or derived)
              </p>
            </div>
            <div><Label htmlFor="audit_log_file">Audit Log File Path</Label><Input id="audit_log_file" value={config.audit_log_file} readOnly /></div>
            <div><Label htmlFor="fuzzy_search_log_file">Fuzzy Search Log File Path</Label><Input id="fuzzy_search_log_file" value={config.fuzzy_search_log_file} readOnly /></div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Editable Runtime Settings</CardTitle>
            <CardDescription>
              Changes are applied in-memory for the current session.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="allowed_directories_str">Allowed Directories (Env: ALLOWED_DIRECTORIES)</Label>
              <Tooltip>
                <TooltipTrigger className="w-full">
                  <Textarea id="allowed_directories_str" name="allowed_directories_str" value={editableConfig.allowed_directories_str} onChange={handleInputChange} placeholder="e.g., /path/project1,~/project2" rows={3}/>
                </TooltipTrigger>
                <TooltipContent><p>Comma-separated list of absolute or tilde-expanded paths. Empty defaults to FILES_ROOT.</p></TooltipContent>
              </Tooltip>
              <Button onClick={() => { void handleSaveSetting("allowedDirectories", editableConfig.allowed_directories_str.split(",").map(s => s.trim()).filter(s => s)); }}>Save Allowed Dirs</Button>
            </div>

            <div className="space-y-2">
              <Label htmlFor="blocked_commands_str">Blocked Commands (Env: BLOCKED_COMMANDS)</Label>
               <Tooltip>
                <TooltipTrigger className="w-full">
                  <Textarea id="blocked_commands_str" name="blocked_commands_str" value={editableConfig.blocked_commands_str} onChange={handleInputChange} placeholder="e.g., rm,sudo" rows={3}/>
                </TooltipTrigger>
                <TooltipContent><p>Comma-separated list of command names to block.</p></TooltipContent>
              </Tooltip>
              <Button onClick={() => { void handleSaveSetting("blockedCommands", editableConfig.blocked_commands_str.split(",").map(s => s.trim()).filter(s => s)); }}>Save Blocked Cmds</Button>
            </div>

            <div className="space-y-2">
              <Label htmlFor="default_shell_str">Default Shell (Env: DEFAULT_SHELL)</Label>
              <Tooltip>
                <TooltipTrigger className="w-full">
                  <Input id="default_shell_str" name="default_shell_str" value={editableConfig.default_shell_str} onChange={handleInputChange} placeholder="e.g., bash (empty for system default)"/>
                </TooltipTrigger>
                <TooltipContent><p>Shell for `execute_command`. System default if empty.</p></TooltipContent>
              </Tooltip>
              <Button onClick={() => { void handleSaveSetting("defaultShell", editableConfig.default_shell_str || null); }}>Save Default Shell</Button>
            </div>

            <div className="space-y-2">
              <Label htmlFor="log_level">Log Level (Env: LOG_LEVEL)</Label>
              <Select
                name="log_level"
                value={editableConfig.log_level}
                onValueChange={(value: string) => { handleSelectChange("log_level", value); }}
              >
                <SelectTrigger id="log_level"><SelectValue placeholder="Select log level" /></SelectTrigger>
                <SelectContent>
                  <SelectItem value="trace">Trace</SelectItem>
                  <SelectItem value="debug">Debug</SelectItem>
                  <SelectItem value="info">Info</SelectItem>
                  <SelectItem value="warn">Warn</SelectItem>
                  <SelectItem value="error">Error</SelectItem>
                </SelectContent>
              </Select>
              <p className="text-sm text-muted-foreground">Backend restart may be needed for full effect.</p>
              <Button onClick={() => { void handleSaveSetting("logLevel", editableConfig.log_level); }}>Save Log Level</Button>
            </div>

            <div className="space-y-2">
              <Label htmlFor="file_read_line_limit_str">File Read Line Limit (Env: FILE_READ_LINE_LIMIT)</Label>
              <Input id="file_read_line_limit_str" name="file_read_line_limit_str" type="number" value={editableConfig.file_read_line_limit_str} onChange={handleInputChange}/>
              <Button onClick={() => { void handleSaveSetting("fileReadLineLimit", parseInt(editableConfig.file_read_line_limit_str, 10) || 1000); }}>Save Read Limit</Button>
            </div>

            <div className="space-y-2">
              <Label htmlFor="file_write_line_limit_str">File Write Line Limit (Env: FILE_WRITE_LINE_LIMIT)</Label>
              <p className="text-sm text-muted-foreground">Max lines for `write_file`/`edit_block` per call.</p>
              <Input id="file_write_line_limit_str" name="file_write_line_limit_str" type="number" value={editableConfig.file_write_line_limit_str} onChange={handleInputChange}/>
              <Button onClick={() => { void handleSaveSetting("fileWriteLineLimit", parseInt(editableConfig.file_write_line_limit_str, 10) || 50); }}>Save Write Limit</Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </TooltipProvider>
  );
}
</file>

<file path="src/app/layout.tsx">
// FILE: src/app/layout.tsx
// IMPORTANT NOTE: Rewrite the entire file.
"use client"; // Required for client-side hooks and context

const Geist_Sans = { variable: "font-sans" };
const Geist_Mono = { variable: "font-mono" };
import "@/styles/globals.css";
import { Toaster } from "@/components/ui/sonner"; // Assuming Shadcn UI Toaster

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className={`${Geist_Sans.variable} ${Geist_Mono.variable}`}>
      <body>
        <main className="min-h-screen"> {/* Ensure main content area can grow */}
          {children}
        </main>
        <Toaster /> {/* Global Toaster for notifications */}
      </body>
    </html>
  );
}
</file>

<file path="src/styles/globals.css">
@import "tw-animate-css";
/*
  ---break---
*/
@custom-variant dark (&:is(.dark *));
/*
  ---break---
*/
@tailwind base;
@tailwind components;
@tailwind utilities;

/*
  Ensure these variables are defined if Geist font is used as in layout.tsx.
  If not using Geist, you can remove these or set to your preferred fallbacks.
*/
:root {
  --font-geist-sans: "Geist Sans", system-ui, sans-serif;
  --font-geist-mono: "Geist Mono", monospace;

  /* Shadcn UI theming variables - ensure these are defined for components to work */
  /* These are example values, adjust them based on your actual theme setup */

  --muted: oklch(0.97 0.001 106.424);
  --muted-foreground: oklch(0.553 0.013 58.071);

  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.147 0.004 49.25);

  --card: oklch(1 0 0);
  --card-foreground: oklch(0.147 0.004 49.25);

  --border: oklch(0.923 0.003 48.717);
  --input: oklch(0.923 0.003 48.717);

  --primary: oklch(0.216 0.006 56.043);
  --primary-foreground: oklch(0.985 0.001 106.423);

  --secondary: oklch(0.97 0.001 106.424);
  --secondary-foreground: oklch(0.216 0.006 56.043);

  --accent: oklch(0.97 0.001 106.424);
  --accent-foreground: oklch(0.216 0.006 56.043);

  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: 210 40% 98%;

  --ring: oklch(0.709 0.01 56.259);

  --radius: 0.625rem;

  --background: oklch(1 0 0);

  --foreground: oklch(0.147 0.004 49.25);

  --chart-1: oklch(0.646 0.222 41.116);

  --chart-2: oklch(0.6 0.118 184.704);

  --chart-3: oklch(0.398 0.07 227.392);

  --chart-4: oklch(0.828 0.189 84.429);

  --chart-5: oklch(0.769 0.188 70.08);

  --sidebar: oklch(0.985 0.001 106.423);

  --sidebar-foreground: oklch(0.147 0.004 49.25);

  --sidebar-primary: oklch(0.216 0.006 56.043);

  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);

  --sidebar-accent: oklch(0.97 0.001 106.424);

  --sidebar-accent-foreground: oklch(0.216 0.006 56.043);

  --sidebar-border: oklch(0.923 0.003 48.717);

  --sidebar-ring: oklch(0.709 0.01 56.259);
}

.dark {
  --background: oklch(0.147 0.004 49.25);
  --foreground: oklch(0.985 0.001 106.423);

  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 56.259);

  --popover: oklch(0.216 0.006 56.043);
  --popover-foreground: oklch(0.985 0.001 106.423);

  --card: oklch(0.216 0.006 56.043);
  --card-foreground: oklch(0.985 0.001 106.423);

  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);

  --primary: oklch(0.923 0.003 48.717);
  --primary-foreground: oklch(0.216 0.006 56.043);

  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.985 0.001 106.423);

  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.985 0.001 106.423);

  --destructive: oklch(0.704 0.191 22.216);
  --destructive-foreground: 210 40% 98%;

  --ring: oklch(0.553 0.013 58.071);

  --chart-1: oklch(0.488 0.243 264.376);

  --chart-2: oklch(0.696 0.17 162.48);

  --chart-3: oklch(0.769 0.188 70.08);

  --chart-4: oklch(0.627 0.265 303.9);

  --chart-5: oklch(0.645 0.246 16.439);

  --sidebar: oklch(0.216 0.006 56.043);

  --sidebar-foreground: oklch(0.985 0.001 106.423);

  --sidebar-primary: oklch(0.488 0.243 264.376);

  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);

  --sidebar-accent: oklch(0.268 0.007 34.298);

  --sidebar-accent-foreground: oklch(0.985 0.001 106.423);

  --sidebar-border: oklch(1 0 0 / 10%);

  --sidebar-ring: oklch(0.553 0.013 58.071);
}

body {
  font-family: var(--font-geist-sans);
  color: hsl(var(--foreground));
  background-color: hsl(var(--background));
}

/* Additional global styles can go here */

/*
  ---break---
*/

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

/*
  ---break---
*/

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Default permissions for MCP-RG-Editor Tauri application.",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "shell:default",
    {
      "identifier": "shell:allow-execute",
      "allow": [
        { "name": "allow-rg-execution", "cmd": "rg", "args": true},
        { "name": "allow-sh-c", "cmd": "sh", "args": ["-c", { "validator": ".*" }]},
        { "name": "allow-bash-c", "cmd": "bash", "args": ["-c", { "validator": ".*" }] },
        { "name": "allow-powershell-command", "cmd": "powershell", "args": ["-Command", { "validator": ".*" }]},
        { "name": "allow-cmd-c", "cmd": "cmd", "args": ["/C", { "validator": ".*" }]}
      ]
    },
    "fs:default",
    "process:default",
    "http:default",
    "dialog:default",
    "notification:default",
    "log:default"
  ],
  "globalScope": {
    "fs": {
      "allow": [
        "$APPCONFIG/**",
        "$APPLOG/**",
        "$APPDATA/**",
        "$APPCACHE/**",
        "$DESKTOP/**",
        "$DOCUMENT/**",
        "$DOWNLOAD/**",
        "$HOME/**"
      ]
    }
  }
}
</file>

<file path="src-tauri/src/config.rs">
use anyhow::{Context, Result};
use regex::Regex;
use shellexpand;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use tauri::Manager;
use tracing::warn;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Config {
    pub files_root: PathBuf,
    pub allowed_directories: Vec<PathBuf>,
    pub blocked_commands: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_shell: Option<String>,
    pub log_level: String,
    pub mcp_transport_mode: TransportMode,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mcp_sse_host: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mcp_sse_port: Option<u16>,
    pub file_read_line_limit: usize,
    pub file_write_line_limit: usize,
    pub audit_log_file: PathBuf,
    pub audit_log_max_size_bytes: u64,
    pub fuzzy_search_log_file: PathBuf,
    pub mcp_log_dir: PathBuf,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)] // Added Eq
pub enum TransportMode {
    Stdio,
    Sse,
    Disabled,
}

impl FromStr for TransportMode {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "stdio" => Ok(TransportMode::Stdio),
            "sse" => Ok(TransportMode::Sse),
            "disabled" => Ok(TransportMode::Disabled),
            _ => Err(anyhow::anyhow!("Invalid MCP transport mode: {}. Valid options are 'stdio', 'sse', 'disabled'.", s)),
        }
    }
}

pub fn expand_tilde(path_str: &str) -> Result<PathBuf, anyhow::Error> {
    Ok(PathBuf::from(shellexpand::tilde(path_str).as_ref()))
}

impl Config {
    pub fn load(app_handle: &tauri::AppHandle) -> Result<Self> {
        dotenvy::dotenv().ok();

        let files_root_str = std::env::var("FILES_ROOT")
            .context("FILES_ROOT environment variable must be set (e.g., ~/mcp_files or an absolute path)")?;
        let initial_files_root = expand_tilde(&files_root_str)?;

        let files_root = initial_files_root.canonicalize().or_else(|e| {
            warn!(path = %initial_files_root.display(), error = %e, "FILES_ROOT failed to canonicalize, attempting to create it.");
            std::fs::create_dir_all(&initial_files_root).context(format!("Failed to create FILES_ROOT: {}", initial_files_root.display()))?;
            initial_files_root.canonicalize().context(format!("Failed to canonicalize FILES_ROOT after creation: {}", initial_files_root.display()))
        })?;

        if !files_root.is_dir() {
            anyhow::bail!("FILES_ROOT is not a valid directory: {:?}", files_root);
        }

        let allowed_directories_str = std::env::var("ALLOWED_DIRECTORIES").unwrap_or_default();
        let mut allowed_directories: Vec<PathBuf> = if allowed_directories_str.is_empty() {
            vec![files_root.clone()]
        } else if allowed_directories_str == "/" || (cfg!(windows) && Regex::new(r"^[a-zA-Z]:[\\/]?$").unwrap().is_match(&allowed_directories_str)) {
            warn!("ALLOWED_DIRECTORIES is set to full filesystem access ('{}'). This is highly permissive.", allowed_directories_str);
            vec![PathBuf::from(allowed_directories_str.trim_end_matches(|c| c == '/' || c == '\\'))]
        } else {
            allowed_directories_str
                .split(',')
                .map(|s| s.trim())
                .filter(|s| !s.is_empty())
                .map(|s| expand_tilde(s).context(format!("Failed to expand tilde for allowed_directory: {}", s)))
                .collect::<Result<Vec<PathBuf>>>()?
                .into_iter()
                .map(|p| p.canonicalize().unwrap_or_else(|_| p.clone()))
                .collect()
        };
        
        let is_files_root_broad = files_root == Path::new("/") || 
                                (cfg!(windows) && files_root.parent().is_none() && files_root.is_absolute());

        if !is_files_root_broad {
            if !allowed_directories.iter().any(|ad| ad == &files_root) {
                allowed_directories.push(files_root.clone());
            }
        }
        allowed_directories.sort();
        allowed_directories.dedup();

        let blocked_commands_str = std::env::var("BLOCKED_COMMANDS")
            .unwrap_or_else(|_| "sudo,su,rm,mkfs,fdisk,dd,reboot,shutdown,poweroff,halt,format,mount,umount,passwd,adduser,useradd,usermod,groupadd".to_string());
        let blocked_commands = blocked_commands_str
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect::<Vec<String>>();

        let default_shell = std::env::var("DEFAULT_SHELL").ok().filter(|s| !s.is_empty());
        let log_level = std::env::var("LOG_LEVEL").unwrap_or_else(|_| "info".to_string());

        let mcp_transport_mode_str = std::env::var("MCP_TRANSPORT").unwrap_or_else(|_| {
            if cfg!(feature = "mcp-sse-server") { "sse".to_string() }
            else if cfg!(feature = "mcp-stdio-server") { "stdio".to_string() }
            else { "disabled".to_string() }
        });
        let mcp_transport_mode = TransportMode::from_str(&mcp_transport_mode_str)?;
        let mcp_sse_host = std::env::var("MCP_SSE_HOST").ok();
        let mcp_sse_port = std::env::var("MCP_SSE_PORT")
            .ok()
            .and_then(|s| s.parse::<u16>().ok());

        let file_read_line_limit = std::env::var("FILE_READ_LINE_LIMIT")
            .unwrap_or_else(|_| "1000".to_string())
            .parse::<usize>()
            .context("Invalid FILE_READ_LINE_LIMIT")?;
        let file_write_line_limit = std::env::var("FILE_WRITE_LINE_LIMIT")
            .unwrap_or_else(|_| "50".to_string())
            .parse::<usize>()
            .context("Invalid FILE_WRITE_LINE_LIMIT")?;
        
        let app_log_dir_base = app_handle.path().app_log_dir()
            .context("Failed to get app log directory from Tauri")?;

        let mcp_log_dir_env_var = std::env::var("MCP_LOG_DIR").ok();
        let mcp_log_dir_path = match mcp_log_dir_env_var {
            Some(dir_str) if !dir_str.is_empty() => expand_tilde(&dir_str)?,
            _ => app_log_dir_base.join("mcp-rg-editor-logs"),
        };

        if !mcp_log_dir_path.exists() {
            std::fs::create_dir_all(&mcp_log_dir_path).context(format!("Failed to create MCP_LOG_DIR: {}", mcp_log_dir_path.display()))?;
        }
        let mcp_log_dir = mcp_log_dir_path.canonicalize().context(format!("Failed to canonicalize MCP_LOG_DIR: {}", mcp_log_dir_path.display()))?;

        let audit_log_file = mcp_log_dir.join("audit_tool_calls.log");
        let audit_log_max_size_bytes = std::env::var("AUDIT_LOG_MAX_SIZE_MB")
            .unwrap_or_else(|_| "10".to_string())
            .parse::<u64>()
            .map(|mb| mb * 1024 * 1024) 
            .unwrap_or(10 * 1024 * 1024); 
        let fuzzy_search_log_file = mcp_log_dir.join("fuzzy_search_attempts.log");

        Ok(Config {
            files_root,
            allowed_directories,
            blocked_commands,
            default_shell,
            log_level,
            mcp_transport_mode,
            mcp_sse_host,
            mcp_sse_port,
            file_read_line_limit,
            file_write_line_limit,
            audit_log_file,
            audit_log_max_size_bytes,
            fuzzy_search_log_file,
            mcp_log_dir,
        })
    }

    pub fn get_blocked_command_regexes(&self) -> Result<Vec<Regex>> {
        self.blocked_commands
            .iter()
            .map(|s| Regex::new(&format!(r"^(?:[a-zA-Z_][a-zA-Z0-9_]*=[^ ]* )*{}(?:\s.*|$)", regex::escape(s)))
                .context(format!("Invalid regex for blocked command: {}", s)))
            .collect()
    }
}

pub fn init_config_state(app_handle: &tauri::AppHandle) -> std::sync::Arc<std::sync::RwLock<Config>> {
    let config = Config::load(app_handle).expect("Failed to load configuration at startup");
    std::sync::Arc::new(std::sync::RwLock::new(config))
}
</file>

<file path="src-tauri/src/error.rs">
use serde::Serialize;
use thiserror::Error;

#[derive(Error, Debug, Serialize)]
pub enum AppError {
    #[error("I/O error: {0}")]
    StdIoError(String),

    #[error("Tokio I/O error: {0}")]
    TokioIoError(String),

    #[error("Ripgrep error: {0}")]
    RipgrepError(String),

    #[error("Path traversal attempt: {0}")]
    PathTraversal(String),

    #[error("Path not allowed: {0}")]
    PathNotAllowed(String),

    #[error("Invalid path: {0}")]
    InvalidPath(String),

    #[error("Configuration error: {0}")]
    ConfigError(String),

    #[error("Command execution error: {0}")]
    CommandExecutionError(String),

    #[error("Command blocked: {0}")]
    CommandBlocked(String),

    #[error("Process error: {0}")]
    ProcessError(String),

    #[error("Session not found for ID: {0}")]
    SessionNotFound(String),

    #[error("Edit error: {0}")]
    EditError(String),

    #[error("Serde JSON error: {0}")]
    SerdeJsonError(String),

    #[error("Reqwest HTTP error: {0}")]
    ReqwestError(String),

    #[error("Operation timed out: {0}")]
    TimeoutError(String),

    #[error("Invalid input argument: {0}")]
    InvalidInputArgument(String),

    #[error("Tauri API error: {0}")]
    TauriApiError(String),

    #[error("Tauri Plugin error ({plugin}): {message}")]
    PluginError { plugin: String, message: String },

    #[error("MCP SDK error: {0}")]
    McpSdkError(String),

    #[error("Unknown error: {0}")]
    Unknown(String),
}

// Removed: impl From<std::io::Error> for AppError to resolve conflict.
// Manually map std::io::Error where needed: .map_err(|e| AppError::StdIoError(e.to_string()))

impl From<tokio::io::Error> for AppError {
    fn from(err: tokio::io::Error) -> Self {
        AppError::TokioIoError(err.to_string())
    }
}

impl From<serde_json::Error> for AppError {
    fn from(err: serde_json::Error) -> Self {
        AppError::SerdeJsonError(err.to_string())
    }
}

impl From<anyhow::Error> for AppError {
    fn from(err: anyhow::Error) -> Self {
        // Attempt to downcast to AppError first to avoid wrapping AppError in AppError
        if let Some(app_err) = err.downcast_ref::<AppError>() {
            // This might involve cloning or a more sophisticated way to handle it
            // For now, let's just re-serialize its string representation if it's already AppError
            // A better approach might be to ensure AppError is not wrapped by anyhow in the first place
            // or to have a more direct way to extract it.
            // Cloning the AppError if it's cloneable is better.
            // For simplicity, using its string representation for now if not Clone.
            // If AppError becomes Clone: return app_err.clone();
            return AppError::Unknown(format!("Wrapped AppError: {}", app_err));
        }
        AppError::ConfigError(format!("{:?}", err))
    }
}


impl From<reqwest::Error> for AppError {
    fn from(err: reqwest::Error) -> Self {
        AppError::ReqwestError(err.to_string())
    }
}

impl From<tauri::Error> for AppError {
    fn from(err: tauri::Error) -> Self {
        AppError::TauriApiError(format!("{:?}", err))
    }
}

impl From<rust_mcp_sdk::error::McpSdkError> for AppError {
    fn from(err: rust_mcp_sdk::error::McpSdkError) -> Self {
        AppError::McpSdkError(format!("{:?}", err))
    }
}

impl From<AppError> for String {
    fn from(error: AppError) -> Self {
        error.to_string()
    }
}
</file>

<file path="src-tauri/src/lib.rs">
mod commands;
mod config;
mod error;
mod utils;
mod mcp;

use crate::commands::terminal_commands::ActiveSessionsMap;
use crate::config::{Config, init_config_state, TransportMode as AppTransportMode};
use crate::mcp::handler::EnhancedServerHandler;
use crate::mcp::McpServerLaunchParams;

use std::sync::Arc;
use tauri::Manager;
use tracing::Level;
use tracing_subscriber::{filter::EnvFilter, fmt::format::FmtSpan, layer::SubscriberExt, util::SubscriberInitExt, Layer as TracingLayerExt}; // Renamed Layer to avoid conflict

use rust_mcp_sdk::McpServer;
use rust_mcp_sdk::mcp_server::{server_runtime, ServerRuntime as McpServerRuntime};
use rust_mcp_sdk::error::McpSdkError;
use rust_mcp_schema::{InitializeResult as McpInitializeResult, Implementation as McpImplementation, ServerCapabilities as McpServerCapabilities, ServerCapabilitiesTools as McpServerCapabilitiesTools, LATEST_PROTOCOL_VERSION as MCP_LATEST_PROTOCOL_VERSION};
use rust_mcp_transport::{StdioTransport as McpStdioTransport, TransportOptions as McpTransportOptions};
use tauri_plugin_dialog::{DialogExt, MessageDialogButtons};
use tauri_plugin_log::TauriLogger; // Assuming this is the correct type for the layer

#[cfg(feature = "mcp-sse-server")]
use rust_mcp_sdk::hyper_server::{create_server as create_mcp_sse_server, HyperServerOptions as McpHyperServerOptions, HyperServerRuntime as McpHyperServerRuntime};


fn setup_tracing_and_logging(log_level_str: &str, app_handle: &tauri::AppHandle) {
    let level = match log_level_str.to_lowercase().as_str() {
        "trace" => Level::TRACE,
        "debug" => Level::DEBUG,
        "info" => Level::INFO,
        "warn" => Level::WARN,
        "error" => Level::ERROR,
        _ => Level::INFO,
    };

    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", level)));

    let fmt_layer = tracing_subscriber::fmt::layer()
        .with_target(true)
        .with_ansi(false) // Typically false for file logs
        .with_writer(std::io::stderr) // For console output via tracing
        .with_level(true)
        .with_span_events(FmtSpan::CLOSE);

    let tauri_log_targets = [
        tauri_plugin_log::Target::new(tauri_plugin_log::TargetKind::LogDir {
            file_name: Some("app_backend.log".into()),
        })
        .filter(EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", level))), // Corrected method name
        tauri_plugin_log::Target::new(tauri_plugin_log::TargetKind::Webview)
            .filter(EnvFilter::new(format!("mcp_rg_editor_tauri_lib={}", Level::INFO))), // Corrected method name
    ];
    
    // Construct the tauri_plugin_log::TauriLogger which implements tracing_subscriber::Layer
    // The builder itself is used to configure the plugin, which is added later.
    // For integrating with tracing_subscriber, we need a Layer.
    // tauri_plugin_log::TauriLogger is the layer provided by the plugin.
    let tauri_log_layer = TauriLogger::new(
        tauri_plugin_log::Builder::default()
            .targets(tauri_log_targets)
            .level_for("hyper", tracing::Level::WARN) // Corrected to tracing::Level
            .level_for("rustls", tracing::Level::WARN) // Corrected to tracing::Level
            .build() // This build() is for the config part of TauriLogger
    );


    tracing_subscriber::registry()
        .with(fmt_layer)
        .with(tauri_log_layer) // Add the TauriLogger layer
        .with(env_filter)
        .init();
    
    tracing::info!("Tracing subscriber and tauri-plugin-log initialized. Global log level: {}", level);
}


fn get_mcp_server_details(_app_config: &Config) -> McpInitializeResult {
    McpInitializeResult {
        server_info: McpImplementation {
            name: "mcp-rg-editor-tauri-hosted".to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        },
        capabilities: McpServerCapabilities {
            tools: Some(McpServerCapabilitiesTools { list_changed: None }),
            resources: Some(Default::default()),
            prompts: Some(Default::default()),
            ..Default::default()
        },
        meta: None,
        instructions: Some(
            "MCP Server hosted within Tauri. Tools interact with local system via Tauri plugins.".to_string()
        ),
        protocol_version: MCP_LATEST_PROTOCOL_VERSION.to_string(),
    }
}

fn map_mcp_sdk_error_sync(err: McpSdkError) -> anyhow::Error {
    anyhow::anyhow!("MCP SDK Error: {:?}", err)
}


#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            let app_handle = app.handle().clone();
            let config_state_arc = init_config_state(&app_handle);

            let log_level_for_setup = config_state_arc.read().unwrap().log_level.clone();
            setup_tracing_and_logging(&log_level_for_setup, &app_handle);

            app.manage(config_state_arc.clone());

            let audit_logger = Arc::new(utils::audit_logger::AuditLogger::new(config_state_arc.clone()));
            app.manage(audit_logger);

            let fuzzy_search_logger = Arc::new(utils::fuzzy_search_logger::FuzzySearchLogger::new(config_state_arc.clone()));
            app.manage(fuzzy_search_logger);

            let active_sessions_map: ActiveSessionsMap = Default::default();
            app.manage(active_sessions_map);

            let sysinfo_state_for_mcp_and_commands = Arc::new(tokio::sync::Mutex::new(sysinfo::System::new_all()));
            app.manage(sysinfo_state_for_mcp_and_commands.clone());


            let mcp_app_handle_clone = app_handle.clone();
            let mcp_config_state_clone = config_state_arc.clone();
            
            let mcp_launch_params = McpServerLaunchParams {
                app_handle: mcp_app_handle_clone,
                config_state: mcp_config_state_clone,
            };
            
            tokio::spawn(async move {
                tracing::info!("Attempting to start MCP server...");
                let transport_mode_from_config = {
                    let cfg_guard = mcp_launch_params.config_state.read().expect("Failed to read config for MCP transport");
                    cfg_guard.mcp_transport_mode.clone()
                };

                if transport_mode_from_config == AppTransportMode::Disabled {
                    tracing::info!("MCP_TRANSPORT is 'disabled'. MCP server will not be started.");
                    return;
                }

                let mcp_server_details = {
                    let cfg_guard = mcp_launch_params.config_state.read().expect("Failed to read config for MCP details");
                    get_mcp_server_details(&cfg_guard)
                };

                let mcp_handler = EnhancedServerHandler::new(mcp_launch_params.app_handle.clone(), mcp_launch_params.config_state.clone());

                match transport_mode_from_config {
                    #[cfg(feature = "mcp-stdio-server")]
                    AppTransportMode::Stdio => {
                        tracing::info!("Starting MCP server with STDIO transport.");
                        let mcp_transport_opts = McpTransportOptions::default();
                        match McpStdioTransport::new(mcp_transport_opts) {
                            Ok(transport) => {
                                let mcp_server_runtime: McpServerRuntime = server_runtime::create_server(mcp_server_details, transport, mcp_handler);
                                if let Err(e) = mcp_server_runtime.start().await.map_err(map_mcp_sdk_error_sync) {
                                    tracing::error!("MCP STDIO Server failed to start or shut down with error: {:?}", e);
                                } else {
                                    tracing::info!("MCP STDIO Server shut down.");
                                }
                            }
                            Err(e) => {
                                tracing::error!("Failed to create MCP StdioTransport: {}", e);
                            }
                        }
                    }
                    #[cfg(feature = "mcp-sse-server")]
                    AppTransportMode::Sse => {
                        let (host, port) = {
                            let cfg_guard = mcp_launch_params.config_state.read().expect("Failed to read config for SSE params");
                            let sse_host = cfg_guard.mcp_sse_host.clone().unwrap_or_else(|| "127.0.0.1".to_string());
                            let sse_port = cfg_guard.mcp_sse_port.unwrap_or(3030);
                            (sse_host, sse_port)
                        };
                        tracing::info!("Starting MCP server with SSE transport on {}:{}", host, port);
                        let mcp_sse_options = McpHyperServerOptions {
                            host,
                            port,
                            enable_cors: true,
                            ..Default::default()
                        };
                        let mcp_sse_server_runtime: McpHyperServerRuntime = create_mcp_sse_server(mcp_server_details, mcp_handler, mcp_sse_options);
                         if let Err(e) = mcp_sse_server_runtime.start().await.map_err(map_mcp_sdk_error_sync) {
                            tracing::error!("MCP SSE Server failed to start or shut down with error: {:?}", e);
                        } else {
                            tracing::info!("MCP SSE Server shut down.");
                        }
                    }
                     _ => { 
                        if transport_mode_from_config == AppTransportMode::Stdio && !cfg!(feature="mcp-stdio-server") {
                             tracing::error!("MCP_TRANSPORT is 'stdio' but 'mcp-stdio-server' feature is not enabled in Cargo.toml.");
                        } else if transport_mode_from_config == AppTransportMode::Sse && !cfg!(feature="mcp-sse-server") {
                             tracing::error!("MCP_TRANSPORT is 'sse' but 'mcp-sse-server' feature is not enabled in Cargo.toml.");
                        } else if transport_mode_from_config != AppTransportMode::Stdio && transport_mode_from_config != AppTransportMode::Sse && transport_mode_from_config != AppTransportMode::Disabled {
                             tracing::warn!("Unknown MCP_TRANSPORT mode configured: {:?}. MCP server not started.", transport_mode_from_config);
                        } else if transport_mode_from_config != AppTransportMode::Disabled {
                             tracing::info!("MCP server not started as the configured transport mode ({:?}) feature is not enabled.", transport_mode_from_config);
                        }
                    }
                }
            });


            if which::which("rg").is_err() {
                tracing::warn!("ripgrep (rg) is not installed or not in PATH. `search_code` tool will fail.");
                let dialog_handle = app_handle.dialog();
                dialog_handle
                    .message("The 'search_code' tool requires ripgrep (rg) to be installed and in your system's PATH for full functionality.")
                    .title("Ripgrep Not Found")
                    .kind(tauri_plugin_dialog::MessageDialogKind::Warning)
                    .buttons(MessageDialogButtons::Ok)
                    .show(|_| {});
            }
            tracing::info!(version = %env!("CARGO_PKG_VERSION"), "MCP-RG-Editor Tauri UI backend setup complete.");
            Ok(())
        })
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_process::init())
        .plugin(tauri_plugin_http::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_notification::init())
        // tauri_plugin_log is initialized via setup_tracing_and_logging, not added as a plugin here
        // as it's integrated into the tracing subscriber.
        // If direct plugin usage is needed, add: .plugin(tauri_plugin_log::Builder::default().build())
        // but ensure it doesn't conflict with the tracing layer.
        .invoke_handler(tauri::generate_handler![
            commands::greet,
            commands::config_commands::get_config_command,
            commands::config_commands::set_config_value_command,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="src-tauri/src/mcp/handler.rs">
use crate::config::Config;
use crate::error::AppError;
use crate::mcp::schemas::*;
use crate::mcp::tool_impl;
use crate::utils::audit_logger::AuditLogger as AppAuditLogger;
use crate::utils::fuzzy_search_logger::FuzzySearchLogger as AppFuzzySearchLogger;
use crate::commands::terminal_commands::ActiveSessionsMap;
use sysinfo::System as SysinfoSystem;

use async_trait::async_trait;
use rust_mcp_sdk::McpServer;
use rust_mcp_sdk::mcp_server::ServerHandler;
use rust_mcp_schema::{
    CallToolRequest, CallToolResult, ListToolsRequest, ListToolsResult, Tool, Content, // Content is a valid top-level import
    schema_utils::CallToolError, RpcError, RpcErrorCode, // RpcErrorCode is also a valid top-level import
};
use serde_json::Value;
use std::sync::{Arc, RwLock as StdRwLock};
use tauri::{AppHandle, Manager};
use tokio::sync::Mutex as TokioMutex;
use tracing::{error, info, instrument};

#[derive(Clone)]
pub struct ToolDependencies {
    pub app_handle: AppHandle,
    pub config_state: Arc<StdRwLock<Config>>,
    pub audit_logger: Arc<AppAuditLogger>,
    pub fuzzy_search_logger: Arc<AppFuzzySearchLogger>,
    pub active_sessions_map: ActiveSessionsMap,
    pub sysinfo_state: Arc<TokioMutex<SysinfoSystem>>,
}

#[derive(Clone)]
pub struct EnhancedServerHandler {
   deps: ToolDependencies,
}

impl EnhancedServerHandler {
    pub fn new(app_handle: AppHandle, config_state: Arc<StdRwLock<Config>>) -> Self {
        let audit_logger = app_handle.state::<Arc<AppAuditLogger>>().inner().clone();
        let fuzzy_search_logger = app_handle.state::<Arc<AppFuzzySearchLogger>>().inner().clone();
        let active_sessions_map = app_handle.state::<ActiveSessionsMap>().inner().clone();
        let sysinfo_state = app_handle.state::<Arc<TokioMutex<SysinfoSystem>>>().inner().clone();

        Self {
            deps: ToolDependencies {
                app_handle,
                config_state,
                audit_logger,
                fuzzy_search_logger,
                active_sessions_map,
                sysinfo_state,
            },
        }
    }
}

fn mcp_call_tool_error_from_app_error(app_err: AppError, tool_name: &str) -> CallToolError {
    error!(error = %app_err, tool = tool_name, "Error during MCP tool execution");
    let rpc_error_code = match app_err {
        AppError::InvalidInputArgument(_) | AppError::PathNotAllowed(_) | AppError::PathTraversal(_) | AppError::InvalidPath(_) => RpcErrorCode::InvalidParams,
        AppError::CommandBlocked(_) => RpcErrorCode::ServerError(-32001), 
        _ => RpcErrorCode::InternalError,
    };
    CallToolError::new(RpcError::new(rpc_error_code, app_err.to_string(), None))
}

fn create_mcp_json_call_tool_result(value: Value) -> Result<CallToolResult, CallToolError> {
    let content_item = Content::Other {
        type_: "json".to_string(),
        data: Some(value),
        text: None,
        mime_type: Some("application/json".to_string()),
        resource_id: None,
        name: None,
        size: None,
        created_at: None,
        updated_at: None,
        meta: None,
    };
    Ok(CallToolResult { content: vec![content_item], meta: None, is_error: Some(false) }) // Added is_error
}


#[async_trait]
impl ServerHandler for EnhancedServerHandler {
    #[instrument(skip(self, _request, _runtime))]
    async fn handle_list_tools_request(
        &self,
        _request: ListToolsRequest,
        _runtime: &dyn McpServer,
    ) -> Result<ListToolsResult, RpcError> {
        info!("MCP: Handling list_tools request");
        let tools = vec![
            Tool { name: "mcp_get_config".to_string(), description: Some("Get the MCP server's current runtime configuration.".to_string()), input_schema: get_mcp_config_schema()},
            Tool { name: "read_file".to_string(), description: Some("Read content of a local file or URL.".to_string()), input_schema: read_file_mcp_schema()},
            Tool { name: "write_file".to_string(), description: Some("Write/append content to a file.".to_string()), input_schema: write_file_mcp_schema()},
            Tool { name: "create_directory".to_string(), description: Some("Create directories, including nested ones.".to_string()), input_schema: create_directory_mcp_schema()},
            Tool { name: "list_directory".to_string(), description: Some("List directory contents.".to_string()), input_schema: list_directory_mcp_schema()},
            Tool { name: "move_file".to_string(), description: Some("Move or rename files or directories.".to_string()), input_schema: move_file_mcp_schema()},
            Tool { name: "get_file_info".to_string(), description: Some("Get metadata for a file or directory.".to_string()), input_schema: get_file_info_mcp_schema()},
            Tool { name: "read_multiple_files".to_string(), description: Some("Read multiple local files.".to_string()), input_schema: read_multiple_files_mcp_schema()},
            Tool { name: "search_files".to_string(), description: Some("Find files/dirs by name.".to_string()), input_schema: search_files_mcp_schema()},
            Tool { name: "search_code".to_string(), description: Some("Search code with Ripgrep.".to_string()), input_schema: search_code_mcp_schema()},
            Tool { name: "execute_command".to_string(), description: Some("Run terminal commands. Output is streamed via events if using Tauri UI; for MCP, initial output/status returned.".to_string()), input_schema: execute_command_mcp_schema()},
            Tool { name: "force_terminate_session".to_string(), description: Some("Stop a running command session by its ID.".to_string()), input_schema: force_terminate_mcp_schema()},
            Tool { name: "list_sessions".to_string(), description: Some("List active command sessions.".to_string()), input_schema: list_sessions_mcp_schema()},
            Tool { name: "read_session_output_status".to_string(), description: Some("Get status of a command session. For MCP, this might include buffered output if designed so.".to_string()), input_schema: read_session_output_status_mcp_schema()},
            Tool { name: "list_processes".to_string(), description: Some("List system processes.".to_string()), input_schema: list_processes_mcp_schema()},
            Tool { name: "kill_process".to_string(), description: Some("Terminate a system process by PID.".to_string()), input_schema: kill_process_mcp_schema()},
            Tool { name: "edit_block".to_string(), description: Some("Apply targeted text replacements in a file.".to_string()), input_schema: edit_block_mcp_schema()},
        ];
        Ok(ListToolsResult { tools, meta: None, next_cursor: None })
    }

    #[instrument(skip(self, request, _runtime), fields(tool_name = %request.params.name))]
    async fn handle_call_tool_request(
        &self,
        request: CallToolRequest,
        _runtime: &dyn McpServer,
    ) -> Result<CallToolResult, CallToolError> {
        let tool_name = request.params.name.as_str();
        let args_value = Value::Object(request.params.arguments.clone().unwrap_or_default());
        info!(tool_name = %tool_name, "MCP: Handling call_tool request");
        
        self.deps.audit_logger.log_command_call(&format!("mcp_{}", tool_name), &args_value).await;

        match tool_name {
            "mcp_get_config" => {
                let config_guard = self.deps.config_state.read()
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InternalError, format!("Config lock error: {}", e), None)))?;
                let current_config_data = config_guard.clone();
                drop(config_guard);
                let value_result = serde_json::to_value(current_config_data)
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InternalError, format!("Failed to serialize config: {}", e), None)))?;
                create_mcp_json_call_tool_result(value_result)
            }
            "read_file" => {
                let params: tool_impl::filesystem::ReadFileParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_read_file(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "write_file" => {
                let params: tool_impl::filesystem::WriteFileParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_write_file(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
             "create_directory" => {
                let params: tool_impl::filesystem::CreateDirectoryParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_create_directory(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "list_directory" => {
                let params: tool_impl::filesystem::ListDirectoryParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_list_directory(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "move_file" => {
                let params: tool_impl::filesystem::MoveFileParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_move_file(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "get_file_info" => {
                let params: tool_impl::filesystem::GetFileInfoParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_get_file_info(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "read_multiple_files" => {
                let params: tool_impl::filesystem::ReadMultipleFilesParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_read_multiple_files(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "search_files" => {
                let params: tool_impl::filesystem::SearchFilesParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::filesystem::mcp_search_files(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "search_code" => {
                let params: tool_impl::ripgrep::SearchCodeParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::ripgrep::mcp_search_code(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "execute_command" => {
                let params: tool_impl::terminal::ExecuteCommandParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::terminal::mcp_execute_command(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "force_terminate_session" => {
                let params: tool_impl::terminal::ForceTerminateParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::terminal::mcp_force_terminate_session(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "list_sessions" => {
                let result = tool_impl::terminal::mcp_list_sessions(&self.deps).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "read_session_output_status" => {
                let params: tool_impl::terminal::ReadOutputStatusParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::terminal::mcp_read_session_output_status(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "list_processes" => {
                let result = tool_impl::process::mcp_list_processes(&self.deps).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "kill_process" => {
                let params: tool_impl::process::KillProcessParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::process::mcp_kill_process(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            "edit_block" => {
                let params: tool_impl::edit::EditBlockParamsMCP = serde_json::from_value(args_value.clone())
                    .map_err(|e| CallToolError::new(RpcError::new(RpcErrorCode::InvalidParams, e.to_string(), None)))?;
                let result = tool_impl::edit::mcp_edit_block(&self.deps, params).await.map_err(|e| mcp_call_tool_error_from_app_error(e, tool_name))?;
                create_mcp_json_call_tool_result(serde_json::to_value(result).unwrap())
            }
            _ => {
                error!("MCP: Unknown tool called: {}", tool_name);
                Err(CallToolError::unknown_tool(tool_name.to_string()))
            }
        }
    }
}
</file>

<file path="src-tauri/src/mcp/tool_impl/filesystem.rs">
use crate::config::Config;
use crate::error::AppError;
use crate::mcp::handler::ToolDependencies;
use crate::utils::path_utils::validate_and_normalize_path;
use crate::utils::line_ending_handler::{detect_line_ending, normalize_line_endings, LineEndingStyle};

use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::sync::RwLockReadGuard;
use tauri::AppHandle; // Removed Manager
use tauri_plugin_fs::{DirEntry, FilePath, FsExt, ReadTextFileOptions as FsReadTextFileOptions, WriteTextFileOptions as FsWriteTextFileOptions, DirOptions as FsDirOptions}; // Renamed to avoid conflict
use tracing::{debug, warn, instrument};
use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
use tokio::time::{timeout, Duration};


// --- MCP Specific Parameter Structs ---
#[derive(Debug, Deserialize, Serialize)]
pub struct ReadFileParamsMCP {
    pub path: String,
    #[serde(default)]
    pub is_url: bool,
    #[serde(default)]
    pub offset: usize,
    pub length: Option<usize>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ReadMultipleFilesParamsMCP {
    pub paths: Vec<String>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct WriteFileParamsMCP {
    pub path: String,
    pub content: String,
    #[serde(default = "default_rewrite_mode_mcp")]
    pub mode: WriteModeMCP,
}
fn default_rewrite_mode_mcp() -> WriteModeMCP { WriteModeMCP::Rewrite }

#[derive(Debug, Deserialize, PartialEq, Eq, Clone, Copy, Serialize)] // Added Eq
#[serde(rename_all = "lowercase")]
pub enum WriteModeMCP { Rewrite, Append }

#[derive(Debug, Deserialize, Serialize)]
pub struct CreateDirectoryParamsMCP { pub path: String }
#[derive(Debug, Deserialize, Serialize)]
pub struct ListDirectoryParamsMCP { pub path: String }
#[derive(Debug, Deserialize, Serialize)]
pub struct MoveFileParamsMCP { pub source: String, pub destination: String }
#[derive(Debug, Deserialize, Serialize)]
pub struct GetFileInfoParamsMCP { pub path: String }

#[derive(Debug, Deserialize, Serialize)]
pub struct SearchFilesParamsMCP {
    pub path: String,
    pub pattern: String,
    #[serde(rename = "timeoutMs")]
    pub timeout_ms: Option<u64>,
    #[serde(default)]
    pub recursive: bool,
    #[serde(default = "default_search_max_depth_mcp")]
    pub max_depth: usize,
}
fn default_search_max_depth_mcp() -> usize { 10 }


// --- MCP Specific Result Structs ---
#[derive(Debug, Serialize)]
pub struct FileContentMCP {
    pub path: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text_content: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_data_base64: Option<String>,
    pub mime_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lines_read: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_lines: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truncated: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ReadMultipleFilesResultMCP { pub results: Vec<FileContentMCP> }
#[derive(Debug, Serialize)]
pub struct FileOperationResultMCP { pub success: bool, pub path: String, pub message: String }
#[derive(Debug, Serialize)]
pub struct ListDirectoryResultMCP { pub path: String, pub entries: Vec<DirEntry> } // Changed to DirEntry

#[derive(Debug, Serialize)]
pub struct FileInfoResultMCP {
    pub path: String, pub size: u64, pub is_dir: bool, pub is_file: bool,
    #[serde(skip_serializing_if = "Option::is_none")] pub modified_iso: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")] pub created_iso: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")] pub accessed_iso: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")] pub permissions_octal: Option<String>,
}
#[derive(Debug, Serialize)]
pub struct SearchFilesResultMCP { pub path: String, pub pattern: String, pub matches: Vec<String>, pub timed_out: bool }


const URL_FETCH_TIMEOUT_MS_MCP: u64 = 30000;
const FILE_SEARCH_TIMEOUT_MS_MCP: u64 = 30000;

fn is_image_mime_mcp(mime_type: &str) -> bool {
    mime_type.starts_with("image/") && (mime_type.ends_with("/png") || mime_type.ends_with("/jpeg") || mime_type.ends_with("/gif") || mime_type.ends_with("/webp"))
}

#[instrument(skip(http_client, _app_handle), fields(url = %url_str))]
async fn read_file_from_url_mcp_internal(
    http_client: &reqwest::Client,
    url_str: &str,
    _app_handle: &tauri::AppHandle,
) -> Result<FileContentMCP, AppError> {
    debug!("MCP Tool: Reading file from URL via reqwest");
    let response_res = timeout(Duration::from_millis(URL_FETCH_TIMEOUT_MS_MCP), http_client.get(url_str).send()).await;
    
    let response = match response_res {
        Ok(Ok(resp)) => resp,
        Ok(Err(e)) => return Err(AppError::ReqwestError(e.to_string())),
        Err(_) => return Err(AppError::TimeoutError(format!("URL fetch timed out: {}", url_str))),
    };
    
    let status = response.status();
    if !status.is_success() {
        let err_msg = response.text().await.unwrap_or_else(|_| "Unknown HTTP error".to_string());
        return Err(AppError::ReqwestError(format!("HTTP Error {}: {}", status, err_msg)));
    }

    let mime_type = response.headers().get(reqwest::header::CONTENT_TYPE).and_then(|v|v.to_str().ok()).unwrap_or("application/octet-stream").split(';').next().unwrap_or_default().trim().to_string();
    if is_image_mime_mcp(&mime_type) {
        let bytes = response.bytes().await.map_err(|e|AppError::ReqwestError(e.to_string()))?;
        Ok(FileContentMCP { path: url_str.to_string(), text_content: None, image_data_base64: Some(BASE64_STANDARD.encode(&bytes)), mime_type, lines_read: None, total_lines: None, truncated: None, error: None })
    } else {
        let text = response.text().await.map_err(|e|AppError::ReqwestError(e.to_string()))?;
        let lines_count = text.lines().count();
        Ok(FileContentMCP { path: url_str.to_string(), text_content: Some(text), image_data_base64: None, mime_type, lines_read: Some(lines_count), total_lines: Some(lines_count), truncated: Some(false), error: None })
    }
}

#[instrument(skip(deps, params), fields(path = %params.path, is_url = %params.is_url))]
pub async fn mcp_read_file(deps: &ToolDependencies, params: ReadFileParamsMCP) -> Result<FileContentMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    if params.is_url {
        let client = reqwest::Client::new();
        return read_file_from_url_mcp_internal(&client, &params.path, &deps.app_handle).await;
    }
    let path = validate_and_normalize_path(&params.path, &config_guard, true, false)?; // Pass borrowed string
    if !deps.app_handle.fs_scope().is_allowed(&path) { return Err(AppError::PathNotAllowed(format!("FS scope disallows read: {}", path.display()))); }
    
    let mime_type = mime_guess::from_path(&path).first_or_octet_stream().to_string();
    if is_image_mime_mcp(&mime_type) {
        let bytes = deps.app_handle.read_binary_file(FilePath::Path(path)).await.map_err(|e| AppError::PluginError{ plugin:"fs".to_string(), message:e.to_string()})?;
        Ok(FileContentMCP { path: params.path, text_content: None, image_data_base64: Some(BASE64_STANDARD.encode(&bytes)), mime_type, lines_read: None, total_lines: None, truncated: None, error: None })
    } else {
        let full_content = deps.app_handle.read_text_file(FilePath::Path(path), None::<FsReadTextFileOptions>).await.map_err(|e| AppError::PluginError{ plugin:"fs".to_string(), message:e.to_string()})?;
        let mut lines_iter = full_content.lines();
        let mut content_vec = Vec::new();
        let mut current_line_idx = 0;
        let mut total_lines_count = 0;
        let read_limit = params.length.unwrap_or(config_guard.file_read_line_limit);
        
        for line_str in lines_iter {
            total_lines_count += 1;
            if current_line_idx >= params.offset && content_vec.len() < read_limit { content_vec.push(line_str.to_string()); }
            current_line_idx += 1;
            if content_vec.len() >= read_limit && (params.offset + content_vec.len()) < total_lines_count { break; }
        }
        let text_processed = content_vec.join("\n");
        let lines_read = content_vec.len();
        let truncated = params.offset > 0 || (lines_read == read_limit && (params.offset + lines_read) < total_lines_count);
        Ok(FileContentMCP { path: params.path, text_content: Some(text_processed), image_data_base64: None, mime_type, lines_read: Some(lines_read), total_lines: Some(total_lines_count), truncated: Some(truncated), error: None })
    }
}

#[instrument(skip(deps, params), fields(path = %params.path, mode = ?params.mode))]
pub async fn mcp_write_file(deps: &ToolDependencies, params: WriteFileParamsMCP) -> Result<FileOperationResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let path = validate_and_normalize_path(&params.path, &config_guard, false, true)?; // Pass borrowed string
    let lines: Vec<&str> = params.content.lines().collect();
    if lines.len() > config_guard.file_write_line_limit { return Err(AppError::EditError(format!("Content exceeds line limit {}. Received {}.", config_guard.file_write_line_limit, lines.len()))); }
    
    let final_content_str = if params.mode == WriteModeMCP::Append && deps.app_handle.exists(FilePath::Path(path.clone()), None).await.unwrap_or(false) {
        let existing_content_str = deps.app_handle.read_text_file(FilePath::Path(path.clone()), None::<FsReadTextFileOptions>).await.unwrap_or_default();
        normalize_line_endings(&params.content, detect_line_ending(&existing_content_str)) // Pass borrowed string
    } else { normalize_line_endings(&params.content, if cfg!(windows) {LineEndingStyle::CrLf} else {LineEndingStyle::Lf}) }; // Pass borrowed string
    
    if !deps.app_handle.fs_scope().is_allowed(&path) { return Err(AppError::PathNotAllowed(format!("FS scope disallows write: {}", path.display()))); }
    
    let options = FsWriteTextFileOptions {
        path: FilePath::Path(path.clone()),
        contents: final_content_str,
        append: Some(params.mode == WriteModeMCP::Append),
        base_dir: None,
    };

    deps.app_handle.write_text_file(options).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), message:e.to_string()})?;
    
    Ok(FileOperationResultMCP { success: true, path: params.path, message: format!("Successfully {} content.", if params.mode == WriteModeMCP::Append {"appended"} else {"wrote"})})
}

#[instrument(skip(deps, params), fields(path = %params.path))]
pub async fn mcp_create_directory(deps: &ToolDependencies, params: CreateDirectoryParamsMCP) -> Result<FileOperationResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let path = validate_and_normalize_path(&params.path, &config_guard, false, true)?; // Pass borrowed string
    if !deps.app_handle.fs_scope().is_allowed(&path) { return Err(AppError::PathNotAllowed(format!("FS scope disallows dir creation: {}", path.display()))); }
    deps.app_handle.create_dir(FilePath::Path(path), Some(FsDirOptions { recursive: true })).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
    Ok(FileOperationResultMCP { success: true, path: params.path, message: "Directory created.".to_string() })
}

#[instrument(skip(deps, params), fields(path = %params.path))]
pub async fn mcp_list_directory(deps: &ToolDependencies, params: ListDirectoryParamsMCP) -> Result<ListDirectoryResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let path = validate_and_normalize_path(&params.path, &config_guard, true, false)?; // Pass borrowed string
    if !deps.app_handle.fs_scope().is_allowed(&path) { return Err(AppError::PathNotAllowed(format!("FS scope disallows list: {}", path.display()))); }
    let entries_data = deps.app_handle.read_dir(FilePath::Path(path), Some(FsDirOptions { recursive: false })).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
    Ok(ListDirectoryResultMCP { path: params.path, entries: entries_data })
}

#[instrument(skip(deps, params), fields(source = %params.source, dest = %params.destination))]
pub async fn mcp_move_file(deps: &ToolDependencies, params: MoveFileParamsMCP) -> Result<FileOperationResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let source_path = validate_and_normalize_path(&params.source, &config_guard, true, false)?; // Pass borrowed string
    let dest_path = validate_and_normalize_path(&params.destination, &config_guard, false, true)?; // Pass borrowed string
    if !deps.app_handle.fs_scope().is_allowed(&source_path) || !deps.app_handle.fs_scope().is_allowed(&dest_path.parent().unwrap_or(&dest_path)) {
        return Err(AppError::PathNotAllowed(format!("FS scope disallows move from {} or to {}", source_path.display(), dest_path.parent().unwrap_or(&dest_path).display())));
    }
    deps.app_handle.rename_file(FilePath::Path(source_path), FilePath::Path(dest_path)).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
    Ok(FileOperationResultMCP { success: true, path: params.destination, message: format!("Moved {} to {}.", params.source, params.destination) })
}

#[instrument(skip(deps, params), fields(path = %params.path))]
pub async fn mcp_get_file_info(deps: &ToolDependencies, params: GetFileInfoParamsMCP) -> Result<FileInfoResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let path = validate_and_normalize_path(&params.path, &config_guard, true, false)?; // Pass borrowed string
    if !deps.app_handle.fs_scope().is_allowed(&path) { return Err(AppError::PathNotAllowed(format!("FS scope disallows info: {}", path.display()))); }
    let metadata = deps.app_handle.metadata(FilePath::Path(path.clone())).await.map_err(|e|AppError::PluginError{plugin:"fs".into(), message:e.to_string()})?;
    
    let to_iso = |st_opt_ms: Option<u128>| st_opt_ms.map(|st_ms| {
        let secs = (st_ms / 1000) as i64;
        let nanos = ((st_ms % 1000) * 1_000_000) as u32;
        chrono::DateTime::<chrono::Utc>::from_timestamp(secs, nanos)
            .map(|dt| dt.to_rfc3339_opts(chrono::SecondsFormat::Millis, true))
            .unwrap_or_default()
    });
    
    let std_meta = std::fs::metadata(&path)?; 
    let perms = {
        #[cfg(unix)] {
            use std::os::unix::fs::PermissionsExt;
            Some(format!("{:03o}", std_meta.permissions().mode() & 0o777))
        }
        #[cfg(not(unix))] { None::<String> }
    };
    Ok(FileInfoResultMCP { 
        path: params.path, 
        size: metadata.len(), 
        is_dir: metadata.is_dir, 
        is_file: metadata.is_file, 
        modified_iso: to_iso(metadata.modified_at), 
        created_iso: to_iso(metadata.created_at), 
        accessed_iso: to_iso(metadata.accessed_at), 
        permissions_octal: perms 
    })
}

#[instrument(skip(deps, params), fields(paths_count = %params.paths.len()))]
pub async fn mcp_read_multiple_files(deps: &ToolDependencies, params: ReadMultipleFilesParamsMCP) -> Result<ReadMultipleFilesResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let mut results = Vec::new();
    let http_client = reqwest::Client::new();

    for path_str_from_params in params.paths {
        let path_str = path_str_from_params.clone();
        let is_url = path_str.starts_with("http://") || path_str.starts_with("https://");
        
        let content_res = if is_url {
            read_file_from_url_mcp_internal(&http_client, &path_str, &deps.app_handle).await
        } else {
            match validate_and_normalize_path(&path_str, &config_guard, true, false) {
                Ok(val_path) => {
                    if !deps.app_handle.fs_scope().is_allowed(&val_path) { Err(AppError::PathNotAllowed(format!("FS scope disallows read: {}", val_path.display()))) }
                    else {
                        let mime = mime_guess::from_path(&val_path).first_or_octet_stream().to_string();
                        if is_image_mime_mcp(&mime) {
                            deps.app_handle.read_binary_file(FilePath::Path(val_path)).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), message:e.to_string()})
                                .map(|b| FileContentMCP{path:path_str.clone(), text_content:None, image_data_base64:Some(BASE64_STANDARD.encode(&b)), mime_type:mime, lines_read:None, total_lines:None, truncated:None, error:None})
                        } else {
                            deps.app_handle.read_text_file(FilePath::Path(val_path), None::<FsReadTextFileOptions>).await.map_err(|e|AppError::PluginError{plugin:"fs".to_string(), message:e.to_string()})
                                .map(|txt| { let lc=txt.lines().count(); FileContentMCP{path:path_str.clone(), text_content:Some(txt), image_data_base64:None, mime_type:mime, lines_read:Some(lc), total_lines:Some(lc), truncated:Some(false), error:None}})
                        }
                    }
                }
                Err(e) => Err(e),
            }
        };
        match content_res {
            Ok(c) => results.push(c),
            Err(e) => results.push(FileContentMCP{path:path_str.clone(), text_content:None, image_data_base64:None, mime_type:"error/unknown".into(), lines_read:None, total_lines:None, truncated:None, error:Some(e.to_string())}),
        }
    }
    Ok(ReadMultipleFilesResultMCP { results })
}

#[instrument(skip(app_handle, pattern_lower, matches, config_guard), fields(dir = %dir_to_search.display()))]
async fn search_files_recursive_mcp_internal(
    app_handle: &AppHandle,
    dir_to_search: PathBuf,
    pattern_lower: &str,
    matches: &mut Vec<String>,
    current_depth: usize,
    max_depth: usize,
    files_root_for_relative_path: &Path,
    config_guard: &RwLockReadGuard<'_, Config>, // Pass as reference
) -> Result<(), AppError> {
    if current_depth > max_depth { return Ok(()); }
    
    if !app_handle.fs_scope().is_allowed(&dir_to_search) {
        warn!(path = %dir_to_search.display(), "Search skipped: path not allowed by FS scope.");
        return Ok(());
    }
     if validate_and_normalize_path(dir_to_search.to_str().unwrap_or_default(), config_guard, true, false).is_err() { // Pass config_guard by reference
        warn!(path = %dir_to_search.display(), "Search skipped: path not allowed by config.");
        return Ok(());
    }

    let dir_entries_result = app_handle.read_dir(FilePath::Path(dir_to_search.clone()), Some(FsDirOptions { recursive: false })).await;
    let dir_entries = match dir_entries_result {
        Ok(entries) => entries,
        Err(e) => {
            warn!(path = %dir_to_search.display(), error = %e, "Could not read directory during search_files");
            return Ok(());
        }
    };

    for entry_data in dir_entries {
        let entry_name = entry_data.name.as_ref().map_or_else(String::new, |n| n.to_lowercase());
        let full_path = entry_data.path.clone();

        if entry_name.contains(pattern_lower) {
            if let Ok(relative_path) = full_path.strip_prefix(files_root_for_relative_path) {
                 matches.push(relative_path.to_string_lossy().into_owned());
            } else {
                matches.push(full_path.to_string_lossy().into_owned());
            }
        }
        if entry_data.is_dir.unwrap_or(false) && current_depth < max_depth {
            search_files_recursive_mcp_internal(app_handle, full_path, pattern_lower, matches, current_depth + 1, max_depth, files_root_for_relative_path, config_guard).await?; // Pass config_guard by reference
        }
    }
    Ok(())
}

#[instrument(skip(deps, params), fields(path = %params.path, pattern = %params.pattern))]
pub async fn mcp_search_files(deps: &ToolDependencies, params: SearchFilesParamsMCP) -> Result<SearchFilesResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    let root_search_path = validate_and_normalize_path(&params.path, &config_guard, true, false)?; // Pass borrowed string
    let files_root_clone = config_guard.files_root.clone();
    
    let app_handle_clone = deps.app_handle.clone();
    // let config_state_clone = deps.config_state.clone(); // No longer needed to clone Arc for RwLockReadGuard
    let pattern_lower_clone = params.pattern.to_lowercase();
    let max_depth_clone = params.max_depth;
    let recursive_clone = params.recursive;

    // Pass config_guard by reference to the async block
    let search_operation = async {
        let mut matches = Vec::new();
        
        // The config_guard is already acquired and passed by reference
        if recursive_clone { 
            search_files_recursive_mcp_internal(&app_handle_clone, root_search_path.clone(), &pattern_lower_clone, &mut matches, 0, max_depth_clone, &files_root_clone, &config_guard).await?; 
        } else {
            if !app_handle_clone.fs_scope().is_allowed(&root_search_path) || validate_and_normalize_path(root_search_path.to_str().unwrap_or_default(), &config_guard, true, false).is_err() {
                 warn!(path = %root_search_path.display(), "Search skipped: path not allowed by scope or config.");
                 return Ok(matches);
            }
            let dir_entries = app_handle_clone.read_dir(FilePath::Path(root_search_path), Some(FsDirOptions { recursive: false })).await.map_err(|e| AppError::PluginError { plugin: "fs".to_string(), message: e.to_string() })?;
            for entry_data in dir_entries {
                let entry_name = entry_data.name.as_ref().map_or_else(String::new, |n| n.to_lowercase());
                 if entry_name.contains(&pattern_lower_clone) {
                    if let Ok(relative_path) = entry_data.path.strip_prefix(&files_root_clone) {
                         matches.push(relative_path.to_string_lossy().into_owned());
                    } else { matches.push(entry_data.path.to_string_lossy().into_owned()); }
                }
            }
        }
        matches.sort();
        Ok(matches)
    };
    
    match timeout(Duration::from_millis(params.timeout_ms.unwrap_or(FILE_SEARCH_TIMEOUT_MS_MCP)), search_operation).await {
        Ok(Ok(m)) => Ok(SearchFilesResultMCP { path: params.path, pattern: params.pattern, matches: m, timed_out: false }),
        Ok(Err(e)) => Err(e),
        Err(_) => Ok(SearchFilesResultMCP { path: params.path, pattern: params.pattern, matches: vec![], timed_out: true }),
    }
}
</file>

<file path="src-tauri/src/mcp/tool_impl/ripgrep.rs">
use crate::error::AppError;
use crate::mcp::handler::ToolDependencies;
use crate::utils::path_utils::validate_and_normalize_path;

use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use tauri_plugin_shell::ShellExt; // Corrected import
use tokio::time::{timeout, Duration};
use tracing::{debug, error, instrument, warn};

// --- MCP Specific Parameter Structs ---
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct SearchCodeParamsMCP {
    pub pattern: String,
    #[serde(default)]
    pub path: String,
    #[serde(default, alias = "fixedStrings")]
    pub fixed_strings: bool,
    #[serde(default, alias = "ignoreCase")]
    pub ignore_case: bool,
    #[serde(default)]
    pub case_sensitive: bool,
    #[serde(default = "default_true_mcp_rg")]
    pub line_numbers: bool,
    #[serde(alias = "contextLines")]
    pub context_lines: Option<usize>,
    #[serde(default, alias = "filePattern")]
    pub file_pattern: Option<String>,
    #[serde(alias = "maxDepth")]
    pub max_depth: Option<usize>,
    #[serde(default = "default_usize_1000_mcp_rg")]
    pub max_results: usize,
    #[serde(default, alias = "includeHidden")]
    pub include_hidden: bool,
    #[serde(default, rename = "timeoutMs")]
    pub timeout_ms: Option<u64>,
}
fn default_true_mcp_rg() -> bool { true }
fn default_usize_1000_mcp_rg() -> usize { 1000 }

// --- MCP Specific Result Structs ---
#[derive(Debug, Clone, Serialize)]
pub struct RipgrepMatchMCP {
    pub file: String,
    pub line: u64,
    pub match_text: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct SearchStatsMCP {
    pub matched_lines: usize,
    pub elapsed_ms: u64,
}

#[derive(Debug, Clone, Serialize)]
pub struct SearchCodeResultMCP {
    pub matches: Vec<RipgrepMatchMCP>,
    pub stats: SearchStatsMCP,
    pub timed_out: bool,
    pub error_message: Option<String>,
}

fn get_rg_path_mcp() -> Result<PathBuf, AppError> {
    which::which("rg").map_err(|e| AppError::RipgrepError(format!("rg not found: {}. Please install ripgrep.", e)))
}

#[instrument(skip(deps, params), fields(pattern = %params.pattern, path = %params.path))]
pub async fn mcp_search_code(
    deps: &ToolDependencies,
    params: SearchCodeParamsMCP,
) -> Result<SearchCodeResultMCP, AppError> {
    let rg_exe_path = get_rg_path_mcp()?;
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    debug!("MCP Tool: search_code with params: {:?}", params);

    let search_dir_str = if params.path.is_empty() || params.path == "." {
        config_guard.files_root.to_str().unwrap_or(".").to_string()
    } else { params.path.clone() };

    let search_path_validated = validate_and_normalize_path(&search_dir_str, &config_guard, true, false)?;
    let files_root_for_stripping = config_guard.files_root.clone();
    // Drop config_guard here as it's not needed across await for this function's direct logic
    // It was passed to validate_and_normalize_path which doesn't hold it across await.
    drop(config_guard);


    let mut rg_args = Vec::new();
    rg_args.push("--json".to_string());
    if params.line_numbers { rg_args.push("--line-number".to_string()); }
    if params.fixed_strings { rg_args.push("-F".to_string()); }
    if params.case_sensitive { rg_args.push("-s".to_string()); }
    else if params.ignore_case { rg_args.push("-i".to_string()); }
    if let Some(context) = params.context_lines { if context > 0 { rg_args.push("-C".to_string()); rg_args.push(context.to_string()); }}
    if let Some(glob) = &params.file_pattern { if !glob.is_empty() { rg_args.push("-g".to_string()); rg_args.push(glob.clone()); }}
    if let Some(depth) = params.max_depth { rg_args.push("--max-depth".to_string()); rg_args.push(depth.to_string()); }
    rg_args.push("--max-count".to_string()); rg_args.push(params.max_results.to_string());
    if params.include_hidden { rg_args.push("--hidden".to_string()); }
    rg_args.push(params.pattern.clone());
    rg_args.push(search_path_validated.to_string_lossy().to_string());

    let start_time = std::time::Instant::now();
    let command_future = deps.app_handle.shell().command(rg_exe_path.to_string_lossy().to_string())
        .args(rg_args.clone())
        .current_dir(&search_path_validated)
        .output();
    
    let timeout_duration = Duration::from_millis(params.timeout_ms.unwrap_or(30000));

    match timeout(timeout_duration, command_future).await {
        Ok(Ok(output)) => {
            let elapsed_ms = start_time.elapsed().as_millis() as u64;
            let mut error_message_opt: Option<String> = None;

            if !output.status.success() && output.status.code() != Some(1) {
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();
                error!("Ripgrep command failed with status {:?}: {}", output.status, stderr);
                if output.stdout.is_empty() {
                     return Err(AppError::RipgrepError(format!("rg failed (status: {:?}): {}", output.status, stderr)));
                }
                error_message_opt = Some(format!("rg reported errors (status: {:?}): {}", output.status, stderr));
            }
            if !output.stderr.is_empty() && error_message_opt.is_none() {
                 let stderr_str = String::from_utf8_lossy(&output.stderr).to_string();
                 if !stderr_str.trim().is_empty() {
                    error_message_opt = Some(format!("rg stderr: {}", stderr_str));
                 }
            }

            let stdout = String::from_utf8(output.stdout).map_err(|e| AppError::RipgrepError(format!("rg output not UTF-8: {}", e)))?;
            let mut matches = Vec::new();
            let mut matched_lines_count = 0;

            for line_str in stdout.lines() {
                if line_str.trim().is_empty() { continue; }
                match serde_json::from_str::<serde_json::Value>(line_str) {
                    Ok(json_val) => {
                        let entry_type = json_val.get("type").and_then(|t| t.as_str());
                        if let Some(data) = json_val.get("data") {
                            let path_abs_str = data.get("path").and_then(|p|p.get("text")).and_then(|t|t.as_str()).unwrap_or_default();
                            let line_num = data.get("line_number").and_then(|n|n.as_u64()).unwrap_or(0);
                            let mut match_text_content = String::new();
                            if entry_type == Some("match") {
                                if let Some(subs) = data.get("submatches").and_then(|s|s.as_array()) {
                                    for sub in subs { if let Some(txt_val) = sub.get("match").and_then(|m|m.get("text")) { match_text_content.push_str(txt_val.as_str().unwrap_or(""));}}
                                }
                                matched_lines_count +=1;
                            } else if entry_type == Some("context") {
                                if let Some(txt_val) = data.get("lines").and_then(|l|l.get("text")) { match_text_content.push_str(txt_val.as_str().unwrap_or(""));}
                            } else { continue; }
                            
                            let absolute_match_path = PathBuf::from(path_abs_str);
                            let display_path = match absolute_match_path.strip_prefix(&files_root_for_stripping) {
                                Ok(p) => p.to_string_lossy().into_owned(),
                                Err(_) => path_abs_str.to_string(),
                            };
                            matches.push(RipgrepMatchMCP { file: display_path, line: line_num, match_text: match_text_content.trim_end().to_string() });
                        }
                    }
                    Err(e) => { warn!(error = %e, line = %line_str, "Failed to parse rg JSON line"); }
                }
            }
            Ok(SearchCodeResultMCP { matches, stats: SearchStatsMCP { matched_lines: matched_lines_count, elapsed_ms }, timed_out: false, error_message: error_message_opt })
        },
        Ok(Err(e)) => {
            error!("Error executing ripgrep command via tauri-plugin-shell: {:?}", e);
            Err(AppError::RipgrepError(format!("Shell execution error for ripgrep: {:?}", e)))
        }
        Err(_) => {
            let elapsed_ms = start_time.elapsed().as_millis() as u64;
            warn!(pattern = %params.pattern, path = %params.path, timeout = timeout_duration.as_millis(), "Ripgrep search timed out");
            Ok(SearchCodeResultMCP { matches: vec![], stats: SearchStatsMCP { matched_lines: 0, elapsed_ms }, timed_out: true, error_message: Some("Search operation timed out.".to_string()) })
        }
    }
}
</file>

<file path="src-tauri/src/mcp/tool_impl/terminal.rs">
use crate::config::Config;
use crate::error::AppError;
use crate::mcp::handler::ToolDependencies;
use crate::commands::terminal_commands::ActiveSession;

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tauri::{Emitter}; // Removed AppHandle, Runtime, Manager
use tauri_plugin_shell::{process::CommandEvent, ShellExt, process::Command as TauriShellCommand}; // Removed CommandChild
use tokio::sync::Mutex as TokioMutex;
use tokio::time::{timeout, Duration, Instant as TokioInstant}; // Removed error::Elapsed
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;
use chrono::Utc;
use serde_json::json;

// --- MCP Specific Parameter Structs ---
#[derive(Debug, Deserialize, Serialize)]
pub struct ExecuteCommandParamsMCP {
    pub command: String,
    #[serde(rename = "timeout_ms")]
    pub timeout_ms: Option<u64>,
    pub shell: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ForceTerminateParamsMCP { pub session_id: String }
#[derive(Debug, Deserialize, Serialize)]
pub struct ReadOutputStatusParamsMCP { pub session_id: String }

// --- MCP Specific Result Structs ---
#[derive(Debug, Serialize)]
pub struct ExecuteCommandResultMCP {
    pub session_id: String,
    pub pid: Option<u32>,
    pub initial_output: String,
    pub timed_out: bool,
    pub exit_code: Option<i32>,
    pub message: String,
}

#[derive(Debug, Serialize)]
pub struct ForceTerminateResultMCP { pub session_id: String, pub success: bool, pub message: String }
#[derive(Debug, Serialize)]
pub struct SessionInfoMCP { pub session_id: String, pub command: String, pub pid: Option<u32>, pub is_running: bool, pub start_time_iso: String, pub runtime_ms: u128 }
#[derive(Debug, Serialize)]
pub struct ReadOutputStatusResultMCP { pub session_id: String, pub is_running: bool, pub exit_code: Option<i32>, pub message: String, pub recent_output: Option<String> }


fn is_command_blocked_mcp(command_str: &str, config: &Config) -> bool {
    let first_command_word = command_str.trim_start().split_whitespace().next().unwrap_or("");
    if first_command_word.is_empty() { return false; }
    match config.get_blocked_command_regexes() {
        Ok(regexes) => regexes.iter().any(|regex| regex.is_match(first_command_word)),
        Err(e) => { warn!("Error compiling blocked command regexes: {}. Blocking {} as precaution.", e, first_command_word); config.blocked_commands.iter().any(|b| b == first_command_word)}
    }
}

#[instrument(skip(deps, params), fields(command = %params.command))]
pub async fn mcp_execute_command(deps: &ToolDependencies, params: ExecuteCommandParamsMCP) -> Result<ExecuteCommandResultMCP, AppError> {
    let config_guard = deps.config_state.read().map_err(|e| AppError::ConfigError(format!("Config lock: {}", e)))?;
    if is_command_blocked_mcp(&params.command, &config_guard) {
        return Err(AppError::CommandBlocked(params.command.clone()));
    }
    let cwd_path = config_guard.files_root.clone();
    let shell_to_use_opt = params.shell.clone().or_else(|| config_guard.default_shell.clone());
    drop(config_guard);

    let session_id = Uuid::new_v4().to_string();
    
    let (mut command_obj, _shell_args_for_scope_check, _program_name_for_scope_check): (TauriShellCommand, Vec<String>, String) = 
        if let Some(shell_path_str) = &shell_to_use_opt {
            let mut args = Vec::new();
            if shell_path_str.contains("powershell") || shell_path_str.contains("cmd.exe") { args.push("-Command".to_string()); } 
            else { args.push("-c".to_string()); }
            args.push(params.command.clone());
            (deps.app_handle.shell().command(shell_path_str.clone()).args(args.clone()), args, shell_path_str.clone())
        } else {
            let mut parts = params.command.split_whitespace();
            let prog = parts.next().ok_or_else(|| AppError::CommandExecutionError("Empty command".into()))?;
            let args: Vec<String> = parts.map(String::from).collect();
            (deps.app_handle.shell().command(prog.to_string()).args(args.clone()), args, prog.to_string())
        };
    
    command_obj = command_obj.current_dir(cwd_path);

    debug!(shell = ?shell_to_use_opt, command = %params.command, "MCP Tool: Spawning command via tauri-plugin-shell");
    let (mut rx, child_proc_handle) = command_obj.spawn().map_err(|e| AppError::CommandExecutionError(format!("Spawn failed: {}", e)))?;
    let pid_val = child_proc_handle.pid();

    let active_session_arc = Arc::new(ActiveSession {
        process_child: Arc::new(TokioMutex::new(Some(child_proc_handle))),
        command_str: params.command.clone(),
        exit_code: Arc::new(TokioMutex::new(None)),
        start_time_system: std::time::SystemTime::now(),
        session_id: session_id.clone(),
        pid: Some(pid_val),
    });
    deps.active_sessions_map.lock().await.insert(session_id.clone(), active_session_arc.clone());

    let initial_output_timeout_ms = params.timeout_ms.unwrap_or(1000);
    let mut initial_stdout_lines = Vec::new();
    let mut initial_stderr_lines = Vec::new();
    let mut timed_out_flag = false;
    let mut early_exit_code: Option<i32> = None;

    let output_collection_start_time = TokioInstant::now();
    loop {
        if output_collection_start_time.elapsed() > Duration::from_millis(initial_output_timeout_ms) {
            if early_exit_code.is_none() { timed_out_flag = true; }
            break;
        }
        
        // rx.recv() returns Option<Result<CommandEvent, ShellError>>
        // The timeout is for the recv() operation itself.
        match timeout(Duration::from_millis(50), rx.recv()).await {
            Ok(Some(Ok(event))) => { // Successfully received an event
                match event {
                    CommandEvent::Stdout(line) => initial_stdout_lines.push(String::from_utf8_lossy(&line).into_owned()),
                    CommandEvent::Stderr(line) => initial_stderr_lines.push(String::from_utf8_lossy(&line).into_owned()),
                    CommandEvent::Terminated(payload) => { early_exit_code = payload.code; break; }
                    CommandEvent::Error(msg) => { error!("Cmd error during initial read: {}", msg); early_exit_code = Some(-1); break; }
                    _ => {} // Other events like Pid
                }
            }
            Ok(Some(Err(shell_error))) => { // ShellError from the stream
                error!("rx.recv shell error: {:?}", shell_error); early_exit_code = Some(-2); break;
            }
            Ok(None) => { // Stream ended
                break;
            }
            Err(_elapsed_err) => { /* timeout for this 50ms iteration, continue loop */ }
        }
    }
    
    let combined_initial_output = format!("STDOUT:\n{}\nSTDERR:\n{}", initial_stdout_lines.join("\n"), initial_stderr_lines.join("\n"));

    let app_handle_clone = deps.app_handle.clone();
    let session_id_clone_for_task = session_id.clone();
    let active_session_clone_for_task = active_session_arc.clone();
    let sessions_map_clone_for_task = deps.active_sessions_map.clone();

    if early_exit_code.is_none() {
        tokio::spawn(async move {
            loop {
                match rx.recv().await {
                    Some(Ok(CommandEvent::Stdout(line))) => {
                        app_handle_clone.emit_to("main", &format!("terminal_output_{}", session_id_clone_for_task), json!({"type": "stdout", "data": String::from_utf8_lossy(&line).into_owned()})).unwrap_or_else(|e| error!("Emit stdout failed: {}", e));
                    }
                    Some(Ok(CommandEvent::Stderr(line))) => {
                        app_handle_clone.emit_to("main", &format!("terminal_output_{}", session_id_clone_for_task), json!({"type": "stderr", "data": String::from_utf8_lossy(&line).into_owned()})).unwrap_or_else(|e| error!("Emit stderr failed: {}", e));
                    }
                    Some(Ok(CommandEvent::Terminated(payload))) => {
                        info!(sid = %session_id_clone_for_task, code = ?payload.code, "Background task: Command terminated");
                        *active_session_clone_for_task.exit_code.lock().await = payload.code;
                        app_handle_clone.emit_to("main", &format!("terminal_output_{}", session_id_clone_for_task), json!({"type": "terminated", "code": payload.code, "signal": payload.signal })).unwrap_or_else(|e| error!("Emit terminated failed: {}", e));
                        sessions_map_clone_for_task.lock().await.remove(&session_id_clone_for_task);
                        break;
                    }
                    Some(Ok(CommandEvent::Error(message))) => {
                        error!(sid = %session_id_clone_for_task, message = %message, "Background task: Command error in stream");
                        *active_session_clone_for_task.exit_code.lock().await = Some(-1);
                        app_handle_clone.emit_to("main", &format!("terminal_output_{}", session_id_clone_for_task), json!({"type": "error", "data": message })).unwrap_or_else(|e| error!("Emit error failed: {}", e));
                        sessions_map_clone_for_task.lock().await.remove(&session_id_clone_for_task);
                        break;
                    }
                    Some(Ok(_other_event)) => { /* e.g. CommandEvent::Pid - can ignore or log */ }
                    Some(Err(shell_error)) => { // ShellError from the stream in background task
                        error!(sid = %session_id_clone_for_task, error = ?shell_error, "Background task: Shell error receiving from command stream");
                        *active_session_clone_for_task.exit_code.lock().await = Some(-2); // Indicate receive error
                        app_handle_clone.emit_to("main", &format!("terminal_output_{}", session_id_clone_for_task), json!({"type": "error", "data": format!("Stream shell error: {:?}", shell_error) })).unwrap_or_else(|e_emit| error!("Emit stream error failed: {}", e_emit));
                        sessions_map_clone_for_task.lock().await.remove(&session_id_clone_for_task);
                        break;
                    }
                    None => { // Stream closed
                        info!(sid = %session_id_clone_for_task, "Background task: Command event stream closed");
                        if active_session_clone_for_task.exit_code.lock().await.is_none() {
                            *active_session_clone_for_task.exit_code.lock().await = Some(0);
                        }
                        app_handle_clone.emit_to("main", &format!("terminal_output_{}", session_id_clone_for_task), json!({"type": "finished_stream_closed"})).unwrap_or_else(|e| error!("Emit finished failed: {}", e));
                        sessions_map_clone_for_task.lock().await.remove(&session_id_clone_for_task);
                        break;
                    }
                }
            }
            info!(sid = %session_id_clone_for_task, "Exiting command monitoring background task.");
        });
    } else {
        *active_session_arc.exit_code.lock().await = early_exit_code;
        deps.active_sessions_map.lock().await.remove(&session_id);
    }

    let final_exit_code = *active_session_arc.exit_code.lock().await;
    let message = if timed_out_flag && final_exit_code.is_none() { format!("Cmd started (PID:{:?}, SID:{}), timed out for initial output. Output streamed via events.", pid_val, session_id) }
                  else if final_exit_code.is_none() { format!("Cmd running (PID:{:?}, SID:{}). Output streamed via events.", pid_val, session_id) }
                  else { format!("Cmd finished (PID:{:?}, SID:{}). Exit: {:?}.", pid_val, session_id, final_exit_code) };

    Ok(ExecuteCommandResultMCP { session_id, pid: Some(pid_val), initial_output: combined_initial_output, timed_out: timed_out_flag, exit_code: final_exit_code, message })
}

pub async fn mcp_force_terminate_session(deps: &ToolDependencies, params: ForceTerminateParamsMCP) -> Result<ForceTerminateResultMCP, AppError> {
    let session_id_to_terminate = params.session_id;
    if let Some(session_arc) = deps.active_sessions_map.lock().await.get(&session_id_to_terminate).cloned() {
        let mut child_opt_guard = session_arc.process_child.lock().await;
        if let Some(child_to_kill_instance) = child_opt_guard.take() { // Take ownership by removing from Option
            // child_to_kill_instance is CommandChild
            // .kill() consumes self.
            match child_to_kill_instance.kill() {
                Ok(_) => {
                    info!(sid = %session_id_to_terminate, pid = ?session_arc.pid, "MCP Tool: Termination signal sent.");
                    *session_arc.exit_code.lock().await = Some(-9); // Arbitrary code for killed
                    deps.active_sessions_map.lock().await.remove(&session_id_to_terminate);
                    Ok(ForceTerminateResultMCP { session_id: session_id_to_terminate, success: true, message: "Termination signal sent.".into() })
                }
                Err(e) => {
                    warn!(sid = %session_id_to_terminate, pid = ?session_arc.pid, error = %e, "MCP Tool: Failed to send kill signal");
                    // Since kill() consumed child_to_kill_instance, we cannot put it back.
                    // The child is gone from our perspective. If kill failed, it might still be running OS-side.
                    if session_arc.exit_code.lock().await.is_none() {
                        *session_arc.exit_code.lock().await = Some(-10); // Arbitrary code for kill fail
                    }
                    // We can't put it back, so just remove from map as we can't manage it anymore.
                    deps.active_sessions_map.lock().await.remove(&session_id_to_terminate);
                    Ok(ForceTerminateResultMCP { session_id: session_id_to_terminate, success: false, message: format!("Kill signal failed: {}. Session removed from tracking.", e) })
                }
            }
        } else {
            // Child already taken/terminated from Option
            Ok(ForceTerminateResultMCP { session_id: session_id_to_terminate, success: true, message: "Process already terminated or not found in session's Option.".into() })
        }
    } else { Err(AppError::SessionNotFound(session_id_to_terminate)) }
}


pub async fn mcp_list_sessions(deps: &ToolDependencies) -> Result<Vec<SessionInfoMCP>, AppError> {
    let sessions_map_guard = deps.active_sessions_map.lock().await;
    let mut infos = Vec::new();
    let now_sys_time = std::time::SystemTime::now();

    for (id, session_arc) in sessions_map_guard.iter() {
        let exit_code_val = *session_arc.exit_code.lock().await;
        infos.push(SessionInfoMCP {
            session_id: id.clone(),
            command: session_arc.command_str.clone(),
            pid: session_arc.pid,
            is_running: exit_code_val.is_none(),
            start_time_iso: chrono::DateTime::<Utc>::from(session_arc.start_time_system).to_rfc3339(),
            runtime_ms: now_sys_time.duration_since(session_arc.start_time_system).unwrap_or_default().as_millis(),
        });
    }
    Ok(infos)
}

pub async fn mcp_read_session_output_status(deps: &ToolDependencies, params: ReadOutputStatusParamsMCP) -> Result<ReadOutputStatusResultMCP, AppError> {
    let session_id_to_read = params.session_id;
    if let Some(session_arc) = deps.active_sessions_map.lock().await.get(&session_id_to_read).cloned() {
        let exit_code_val = *session_arc.exit_code.lock().await;
        Ok(ReadOutputStatusResultMCP {
            session_id: session_id_to_read,
            is_running: exit_code_val.is_none(),
            exit_code: exit_code_val,
            message: "Session status. For UI, output is streamed via Tauri events. MCP client cannot directly access this stream without further adaptation.".into(),
            recent_output: None
        })
    } else {
        Ok(ReadOutputStatusResultMCP {
            session_id: session_id_to_read,
            is_running: false,
            exit_code: None, 
            message: "Session not found or already terminated and cleaned up.".into(),
            recent_output: None
        })
    }
}
</file>

<file path="src-tauri/src/utils/path_utils.rs">
use crate::config::Config;
use crate::error::AppError;
use std::path::{Component, Path, PathBuf};
use tracing::debug;
// use std::sync::RwLockReadGuard; // No longer needed as argument type
use shellexpand;

/// Expands tilde (~) in a path string to the user's home directory.
pub fn expand_tilde_path_buf(path_str: &str) -> Result<PathBuf, AppError> {
    Ok(PathBuf::from(shellexpand::tilde(path_str).as_ref()))
}

/// Normalizes a path: expands tilde, makes it absolute relative to files_root if it's relative,
/// and then attempts to canonicalize it. Falls back to a simplified absolute path if canonicalization fails.
fn normalize_path_base(path_str: &str, files_root: &Path) -> Result<PathBuf, AppError> {
    let expanded_path = expand_tilde_path_buf(path_str)?;

    let absolute_path = if expanded_path.is_absolute() { // Corrected: removed mut
        expanded_path
    } else {
        files_root.join(expanded_path)
    };

    match dunce::canonicalize(&absolute_path) {
        Ok(canonical_path) => Ok(canonical_path),
        Err(_) => {
            let mut components_vec = Vec::new();
            for component in absolute_path.components() {
                match component {
                    Component::ParentDir => {
                        if let Some(Component::Normal(_)) = components_vec.last() {
                            components_vec.pop();
                        } else if cfg!(windows) && components_vec.len() == 1 {
                            if let Some(Component::Prefix(_)) = components_vec.first() {
                                // Allow C:\.. -> C:\
                            } else {
                                components_vec.push(component);
                            }
                        } else if cfg!(unix) && components_vec.is_empty() {
                            // Allow /.. -> /.. (or let it be handled by OS later)
                             components_vec.push(component);
                        }
                        // If ParentDir is at the start of a relative path, it's kept.
                         else if components_vec.is_empty() && !absolute_path.is_absolute() {
                            components_vec.push(component);
                        }
                    }
                    Component::CurDir => {}
                    _ => components_vec.push(component),
                }
            }
            Ok(components_vec.iter().collect())
        }
    }
}

pub fn validate_and_normalize_path(
    target_path_str: &str,
    config: &Config, // Changed from &RwLockReadGuard<Config> to &Config
    check_existence: bool,
    for_write_or_create: bool,
) -> Result<PathBuf, AppError> {
    debug!(target_path = %target_path_str, check_existence, for_write_or_create, "Validating path access");

    let normalized_target_path = normalize_path_base(target_path_str, &config.files_root)?;
    debug!(normalized_target_path = %normalized_target_path.display(), "Initial normalized target path");

    let path_for_dir_checks = if for_write_or_create && !normalized_target_path.exists() {
        normalized_target_path.parent().ok_or_else(|| AppError::InvalidPath(format!("Cannot determine parent directory for write/create: {}", normalized_target_path.display())))?.to_path_buf()
    } else {
        normalized_target_path.clone()
    };
    debug!(path_for_dir_checks = %path_for_dir_checks.display(), "Path used for directory/existence checks");

    let is_files_root_broad = config.files_root == Path::new("/") ||
                              (cfg!(windows) && config.files_root.parent().is_none() && config.files_root.is_absolute());

    if !is_files_root_broad && !normalized_target_path.starts_with(&config.files_root) {
        debug!(path = %normalized_target_path.display(), root = %config.files_root.display(), "Path is outside files_root");
        return Err(AppError::PathTraversal(format!(
            "Path {} is outside of the configured root directory {}",
            normalized_target_path.display(),
            config.files_root.display()
        )));
    }

    let is_globally_allowed_by_config = config.allowed_directories.iter().any(|ad_config_path| {
        let normalized_ad = normalize_path_base(ad_config_path.to_str().unwrap_or(""), &config.files_root)
                                .unwrap_or_else(|_| ad_config_path.clone());
        normalized_ad == Path::new("/") || (cfg!(windows) && normalized_ad.parent().is_none() && normalized_ad.is_absolute())
    });

    if is_globally_allowed_by_config {
        debug!("Access globally allowed by an allowed_directory entry like '/' or 'C:\\'");
    } else {
        let is_specifically_allowed = config.allowed_directories.iter().any(|allowed_dir_config_entry| {
            let normalized_allowed_dir = normalize_path_base(allowed_dir_config_entry.to_str().unwrap_or_default(), &config.files_root)
                .unwrap_or_else(|_| allowed_dir_config_entry.clone());
            
            debug!(check_path = %path_for_dir_checks.display(), against_allowed_dir = %normalized_allowed_dir.display(), "Checking specific allowance");
            path_for_dir_checks.starts_with(&normalized_allowed_dir)
        });

        if !is_specifically_allowed {
            debug!(path = %normalized_target_path.display(), checked_against = %path_for_dir_checks.display(), allowed_dirs = ?config.allowed_directories, "Path not in allowed_directories");
            return Err(AppError::PathNotAllowed(format!(
                "Operation on path {} (effective check on {}) is not within any allowed directories. Allowed: {:?}",
                normalized_target_path.display(), path_for_dir_checks.display(), config.allowed_directories
            )));
        }
    }

    if check_existence {
        let path_to_check_existence = if for_write_or_create && !normalized_target_path.exists() {
            &path_for_dir_checks 
        } else {
            &normalized_target_path
        };

        if !path_to_check_existence.exists() {
            return Err(AppError::InvalidPath(format!(
                "Required path (or parent for write/create) does not exist: {}",
                path_to_check_existence.display()
            )));
        }
        if for_write_or_create && path_to_check_existence != &normalized_target_path && !path_to_check_existence.is_dir()  {
             return Err(AppError::InvalidPath(format!(
                "Parent path for write/create is not a directory: {}",
                path_to_check_existence.display()
            )));
        }
    }

    Ok(normalized_target_path)
}
</file>

<file path="src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "MCP-RG-Editor-Tauri",
  "version": "0.1.0",
  "identifier": "com.babybird.mcp-rg-editor",
  "build": {
    "beforeDevCommand": "pnpm dev",
    "devUrl": "http://localhost:3000",
    "beforeBuildCommand": "pnpm build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "MCP-RG Editor",
        "width": 1280,
        "height": 800,
        "resizable": true,
        "fullscreen": false,
        "label": "main"
      }
    ],
    "security": {
      "csp": null,
      "capabilities": [
        "default"
      ]
    },
    "withGlobalTauri": true
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  },
  "plugins": {
    "fs": {
      "scope": [
        "$APPCONFIG/**", "$APPLOG/**", "$APPDATA/**", "$APPCACHE/**",
        "$DESKTOP/**", "$DOCUMENT/**", "$DOWNLOAD/**", "$HOME/**"
      ],
      "globalScope": [ 
        "$APPCONFIG/**", "$APPLOG/**", "$APPDATA/**", "$APPCACHE/**",
        "$DESKTOP/**", "$DOCUMENT/**", "$DOWNLOAD/**", "$HOME/**"
      ]
    },
    "shell": {
      "open": true, 
      "scope": [
        { "name": "allow-rg", "cmd": "rg", "args": true, "sidecar": false },
        { "name": "allow-sh", "cmd": "sh", "args": ["-c", { "validator": "\\S+" }], "sidecar": false },
        { "name": "allow-bash", "cmd": "bash", "args": ["-c", { "validator": "\\S+" }], "sidecar": false },
        { "name": "allow-powershell", "cmd": "powershell", "args": ["-Command", { "validator": "\\S+" }], "sidecar": false },
        { "name": "allow-cmd", "cmd": "cmd", "args": ["/C", { "validator": "\\S+" }], "sidecar": false }
      ]
    },
    "process": {}, 
    "http": {
      "scope": ["https://*/*", "http://*/*"] 
    },
    "dialog": {},
    "notification": {},
    "log": {
      "targets": [
        {"name": "stdout", "level": "info"}, 
        {"name": "logdir", "level": "debug", "path": "$APPLOG"}, 
        {"name": "webview", "level": "info"}
      ],
      "maxSize": 5242880, 
      "rotationStrategy": "KeepOne", 
      "level": "info" 
    }
  }
}
</file>

<file path="README.md">
# Tauri 2.0 + Next.js 15 App Router Template

![Tauri window screenshot](public/tauri-nextjs-template-2_screenshot.png)

This is a [Tauri](https://v2.tauri.app/) project template using [Next.js](https://nextjs.org/),
bootstrapped by combining [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app)
and [`create tauri-app`](https://v2.tauri.app/start/create-project/).

This template uses [`pnpm`](https://pnpm.io/) as the Node.js dependency
manager, and uses the [App Router](https://nextjs.org/docs/app) model for Next.js.

## Template Features

- TypeScript frontend using [Next.js 15](https://nextjs.org/) React framework
- [TailwindCSS 4](https://tailwindcss.com/) as a utility-first atomic CSS framework
  - The example page in this template app has been updated to use only TailwindCSS
  - While not included by default, consider using
    [React Aria components](https://react-spectrum.adobe.com/react-aria/index.html)
    and/or [HeadlessUI components](https://headlessui.com/) for completely unstyled and
    fully accessible UI components, which integrate nicely with TailwindCSS
- Opinionated formatting and linting already setup and enabled
  - [Biome](https://biomejs.dev/) for a combination of fast formatting, linting, and
    import sorting of TypeScript code, and [ESLint](https://eslint.org/) for any missing
    Next.js linter rules not covered by Biome
  - [clippy](https://github.com/rust-lang/rust-clippy) and
    [rustfmt](https://github.com/rust-lang/rustfmt) for Rust code
- GitHub Actions to check code formatting and linting for both TypeScript and Rust

## Getting Started

### Running development server and use Tauri window

After cloning for the first time, change your app identifier inside
`src-tauri/tauri.conf.json` to your own:

```jsonc
{
  // ...
  // The default "com.tauri.dev" will prevent you from building in release mode
  "identifier": "com.my-application-name.app",
  // ...
}
```

To develop and run the frontend in a Tauri window:

```shell
pnpm tauri dev
```

This will load the Next.js frontend directly in a Tauri webview window, in addition to
starting a development server on `localhost:3000`.
Press <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>I</kbd> in a Chromium based WebView (e.g. on
Windows) to open the web developer console from the Tauri window.

### Building for release

To export the Next.js frontend via SSG and build the Tauri application for release:

```shell
pnpm tauri build
```

### Source structure

Next.js frontend source files are located in `src/` and Tauri Rust application source
files are located in `src-tauri/`. Please consult the Next.js and Tauri documentation
respectively for questions pertaining to either technology.

## Caveats

### Static Site Generation / Pre-rendering

Next.js is a great React frontend framework which supports server-side rendering (SSR)
as well as static site generation (SSG or pre-rendering). For the purposes of creating a
Tauri frontend, only SSG can be used since SSR requires an active Node.js server.

Please read into the Next.js documentation for [Static Exports](https://nextjs.org/docs/app/building-your-application/deploying/static-exports)
for an explanation of supported / unsupported features and caveats.

### `next/image`

The [`next/image` component](https://nextjs.org/docs/basic-features/image-optimization)
is an enhancement over the regular `<img>` HTML element with server-side optimizations
to dynamically scale the image quality. This is only supported when deploying the
frontend onto Vercel directly, and must be disabled to properly export the frontend
statically. As such, the
[`unoptimized` property](https://nextjs.org/docs/api-reference/next/image#unoptimized)
is set to true for the `next/image` component in the `next.config.js` configuration.
This will allow the image to be served as-is, without changes to its quality, size,
or format.

### ReferenceError: window/navigator is not defined

If you are using Tauri's `invoke` function or any OS related Tauri function from within
JavaScript, you may encounter this error when importing the function in a global,
non-browser context. This is due to the nature of Next.js' dev server effectively
running a Node.js server for SSR and hot module replacement (HMR), and Node.js does not
have a notion of `window` or `navigator`.

The solution is to ensure that the Tauri functions are imported as late as possible
from within a client-side React component, or via [lazy loading](https://nextjs.org/docs/app/building-your-application/optimizing/lazy-loading).

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and
  API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

And to learn more about Tauri, take a look at the following resources:

- [Tauri Documentation - Guides](https://v2.tauri.app/start/) - learn about the Tauri
  toolkit.
</file>

<file path="src-tauri/src/commands/filesystem_commands.rs">
// This file's commands are now largely superseded by MCP tools.
// If specific UI-only filesystem commands are needed that don't map to MCP,
// they can be re-added here. For now, this file can be simplified or
// its commands can call the MCP tool_impl functions directly if that's desired
// for UI interactions not going through an MCP client.

// For this iteration, we assume UI will eventually use an MCP client or
// these commands will be re-evaluated. Keeping it minimal for now.

// No specific Tauri commands for direct filesystem manipulation are exposed from here
// as they are covered by the MCP tools.
// If you need UI-specific wrappers around MCP logic, define them here.
// Example:
/*
use crate::config::Config;
use crate::error::AppError;
use crate::utils::audit_logger::audit_log;
use crate::mcp::tool_impl::filesystem as mcp_fs_impl;
use crate::mcp::handler::ToolDependencies;

use std::sync::{Arc, RwLock as StdRwLock};
use tauri::{AppHandle, Manager, State};
use sysinfo::System as SysinfoSystem;
use tokio::sync::Mutex as TokioMutex;
use tracing::instrument;

pub use crate::mcp::tool_impl::filesystem::{
    ReadFileParamsMCP as ReadFileParams,
    FileContentMCP as FileContent,
};

fn get_tool_dependencies_for_ui(app_handle: &AppHandle, config_state: &State<'_, Arc<StdRwLock<Config>>>) -> ToolDependencies {
    ToolDependencies {
        app_handle: app_handle.clone(),
        config_state: config_state.inner().clone(),
        audit_logger: app_handle.state::<Arc<crate::utils::audit_logger::AuditLogger>>().inner().clone(),
        fuzzy_search_logger: app_handle.state::<Arc<crate::utils::fuzzy_search_logger::FuzzySearchLogger>>().inner().clone(),
        active_sessions_map: app_handle.state::<crate::commands::terminal_commands::ActiveSessionsMap>().inner().clone(),
        sysinfo_state: app_handle.state::<Arc<TokioMutex<SysinfoSystem>>>().inner().clone(),
    }
}

#[tauri::command(async)]
#[instrument(skip(app_handle, config_state, audit_logger_state, params), fields(path = %params.path))]
pub async fn read_file_command_ui_wrapper( // Example wrapper
    app_handle: AppHandle,
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
    params: ReadFileParams,
) -> Result<FileContent, AppError> {
    audit_log(&audit_logger_state, "ui_read_file_wrapper", &serde_json::to_value(ms)?).await;
    let deps = get_tool_dependencies_for_ui(&app_handle, &config_state);
    mcp_fs_impl::mcp_read_file(&deps, params).await
}
*/

// For now, this file will be empty of commands, assuming MCP is the primary interface.
// If UI needs direct calls, uncomment and adapt the example above.
</file>

<file path="src-tauri/src/commands/ripgrep_commands.rs">
// This file's commands are now largely superseded by MCP tools.
// For this iteration, this file will be empty of commands, assuming MCP is the primary interface.
// If UI needs direct calls to ripgrep logic not via MCP, define them here.
// Example:
/*
use crate::config::Config;
use crate::error::AppError;
use crate::utils::audit_logger::audit_log;
use crate::mcp::tool_impl::ripgrep as mcp_rg_impl;
use crate::mcp::handler::ToolDependencies;

use std::sync::{Arc, RwLock as StdRwLock};
use tauri::{AppHandle, Manager, State};
use sysinfo::System as SysinfoSystem;
use tokio::sync::Mutex as TokioMutex;
use tracing::instrument;

pub use crate::mcp::tool_impl::ripgrep::SearchCodeParamsMCP as SearchCodeParams;
pub use crate::mcp::tool_impl::ripgrep::SearchCodeResultMCP as SearchCodeResult;

fn get_tool_dependencies_for_ui(app_handle: &AppHandle, config_state: &State<'_, Arc<StdRwLock<Config>>>) -> ToolDependencies {
    ToolDependencies {
        app_handle: app_handle.clone(),
        config_state: config_state.inner().clone(),
        audit_logger: app_handle.state::<Arc<crate::utils::audit_logger::AuditLogger>>().inner().clone(),
        fuzzy_search_logger: app_handle.state::<Arc<crate::utils::fuzzy_search_logger::FuzzySearchLogger>>().inner().clone(),
        active_sessions_map: app_handle.state::<crate::commands::terminal_commands::ActiveSessionsMap>().inner().clone(),
        sysinfo_state: app_handle.state::<Arc<TokioMutex<SysinfoSystem>>>().inner().clone(),
    }
}

#[tauri::command(async)]
#[instrument(skip(app_handle, config_state, audit_logger_state, params), fields(pattern = %params.pattern, path = %params.path))]
pub async fn search_code_command_ui_wrapper( // Example wrapper
    app_handle: AppHandle,
    config_state: State<'_, Arc<StdRwLock<Config>>>,
    audit_logger_state: State<'_, Arc<crate::utils::audit_logger::AuditLogger>>,
    params: SearchCodeParams,
) -> Result<SearchCodeResult, AppError> {
    audit_log(&audit_logger_state, "ui_search_code_wrapper", &serde_json::to_value(ms)?).await;
    let deps = get_tool_dependencies_for_ui(&app_handle, &config_state);
    mcp_rg_impl::mcp_search_code(&deps, params).await
}
*/
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/
/dist/

# production
/build
/target

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo

src-tauri/Cargo.lock
diagnostics.json
</file>

<file path="Cargo.toml">
[workspace]
members = [
    "src-tauri"
]
</file>

</files>
